<html>
<head>
  <link rel="stylesheet" href="images/style.css" type="text/css"/>
  <meta http-equiv="content-type" content="text/html;charset=iso-8859-1"/>
</head>

<body>
  <div>
    <table bgcolor="#ffffff" width="100%">

      <!-- header -->

      <tr>
        <td>
          <table id="header" cellspacing="0" cellpadding="0">
            <tr>
              <td><img src="images/yklogo.gif"/></td>
              <td id="header-central-part">
                <table cellpadding="0" cellspacing="0" height="100%">
                  <tr valign="top" hight="100%">
                    <td id="header-logo-row">
                      <table cellpadding="0" cellspacing="0" >
                        <tr>
                          <td><img src="images/yklogo2.gif"/></td>
                          <td id="header-dont-get-lost">Don't get lost in data, get information!</td>
                        </tr>
                      </table>
                    </td>
                  </tr>

                  <!-- navigator -->

                  <tr valign="bottom">
                    <td>
                      <table cellpadding="0" cellspacing="0" width="100%">
                        <tbody>
                          <tr>
                            <td width="100%"/>
                            <td id="header-non-selected-topic"><a class="topic" href="../help/index.html">HELP</a></td>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td id="header-non-selected-topic"><a class="topic" href="../faq/index.html">FAQ</a></td>
<td>&nbsp;&nbsp;</td>
<td>&nbsp;&nbsp;</td>
<td id="header-selected-topic"><nobr>PRINTER FRIENDLY HELP</nobr></td>
                            <td width="100%"/>
                          </tr>
                        </tbody>
                      </table>
                    </td>
                  </tr>

                </table>
              </td>
              <td><img src="images/the-java-profiler.gif"/></td>
            </tr>
          </table>
        </td>
      </tr>

      <!-- content -->

      <tr>
        <td valign="top">
          <div id="topic"><h2>Topics:</h2><ul id="bulletless-list">
<li id="topic-link">1&nbsp;&nbsp;Getting started</li>
<ul id="bulletless-list">
<li id="topic-link">1.1&nbsp;&nbsp;<a href="#index">Running profiler</a></li>
<li id="topic-link">1.2&nbsp;&nbsp;<a href="#running_with_profiler">Running applications with profiler</a></li>
<ul id="bulletless-list">
<li id="topic-link">1.2.1&nbsp;&nbsp;<a href="#agent">Agent configuration</a></li>
</ul>
</ul>
<li id="topic-link">2&nbsp;&nbsp;<a href="#performance_problems">Solution of performance problems</a></li>
<li id="topic-link">3&nbsp;&nbsp;CPU profiling</li>
<ul id="bulletless-list">
<li id="topic-link">3.1&nbsp;&nbsp;<a href="#cpu_howto">How to profile CPU</a></li>
<li id="topic-link">3.2&nbsp;&nbsp;<a href="#cpu_methods">Methods of CPU profiling</a></li>
<li id="topic-link">3.3&nbsp;&nbsp;<a href="#cpu_stat">CPU Statistics view</a></li>
<li id="topic-link">3.4&nbsp;&nbsp;<a href="#cpu_method_view">Method view</a></li>
<li id="topic-link">3.5&nbsp;&nbsp;<a href="#cpu_snapshot_properties">CPU snapshot properties</a></li>
</ul>
<li id="topic-link">4&nbsp;&nbsp;Memory profiling</li>
<ul id="bulletless-list">
<li id="topic-link">4.1&nbsp;&nbsp;<a href="#memory_snapshots">Snapshots</a></li>
<li id="topic-link">4.2&nbsp;&nbsp;<a href="#allocations">Allocation recording</a></li>
<li id="topic-link">4.3&nbsp;&nbsp;<a href="#sizes">Shallow and retained sizes</a></li>
<li id="topic-link">4.4&nbsp;&nbsp;Memory views</li>
<ul id="bulletless-list">
<li id="topic-link">4.4.1&nbsp;&nbsp;<a href="#objects_view">Objects view</a></li>
<ul id="bulletless-list">
<li id="topic-link">4.4.1.1&nbsp;&nbsp;<a href="#objects_view_stat">Statistics</a></li>
<li id="topic-link">4.4.1.2&nbsp;&nbsp;<a href="#objects_view_explorer">Object Explorer</a></li>
<li id="topic-link">4.4.1.3&nbsp;&nbsp;<a href="#objects_view_alloc_hot_spots">Allocation hot spots</a></li>
<li id="topic-link">4.4.1.4&nbsp;&nbsp;<a href="#objects_view_alloc_tree">Allocation call tree</a></li>
</ul>
<li id="topic-link">4.4.2&nbsp;&nbsp;<a href="#garbage">Garbage view</a></li>
<li id="topic-link">4.4.3&nbsp;&nbsp;<a href="#mem_method_view">Method view</a></li>
<li id="topic-link">4.4.4&nbsp;&nbsp;<a href="#gc_roots">GC roots view</a></li>
<li id="topic-link">4.4.5&nbsp;&nbsp;<a href="#paths">Working with paths</a></li>
</ul>
<li id="topic-link">4.5&nbsp;&nbsp;<a href="#compare_snapshots">Ability to compare snapshots</a></li>
<li id="topic-link">4.6&nbsp;&nbsp;<a href="#memory_actions">Useful actions</a></li>
<li id="topic-link">4.7&nbsp;&nbsp;<a href="#memory_snapshot_properties">Memory snapshot properties</a></li>
<li id="topic-link">4.8&nbsp;&nbsp;<a href="#language">Set description language</a></li>
</ul>
<li id="topic-link">5&nbsp;&nbsp;<a href="#ide_integration">IDE integration</a></li>
<ul id="bulletless-list">
<li id="topic-link">5.1&nbsp;&nbsp;<a href="#ide_integration_plugins">Installation of plugins</a></li>
<li id="topic-link">5.2&nbsp;&nbsp;<a href="#ide_integration_run">Run profiling-enabled applications from IDE</a></li>
<li id="topic-link">5.3&nbsp;&nbsp;<a href="#ide_integration_navigation">Navigation action</a></li>
</ul>
<li id="topic-link">6&nbsp;&nbsp;<a href="#filters">Filters</a></li>
<li id="topic-link">7&nbsp;&nbsp;<a href="#options">User interface customization</a></li>
<li id="topic-link">8&nbsp;&nbsp;<a href="#api">Profiler API</a></li>
</ul>
<br/><br/><h2>1&nbsp;&nbsp;Getting started</h2><br/><div><a name="index"></a>
<h2 class="faq">1.1&nbsp;&nbsp;Running profiler</h2>

  Please execute <i>&lt;YJP Home&gt;</i>\bin\yjp.exe under Windows or <i>&lt;YJP Home&gt;</i>/bin/yjp.sh under Linux or Solaris.

  <p>
  Profiler requires Java 1.4.2 or 5.0 to run.
  Please note this is only a requirement of profiler UI; profiled applications can run Java 1.3 or later.
  </p>

  <p>Under Windows, yjp.exe retrieves available Java installations from system registry.</p>

  <p>
  Under Linux or Solaris, startup script yjp.sh sequentially probes:
  <ul>
  <li>JRE/JDK specified via environment variable YJP_JAVA_HOME</li>
  <li>JRE/JDK specified via environment variable JAVA_HOME</li>
  <li>'java' in your current PATH</li>
  </ul>
  </p>

  <p>
  If proper JRE/JDK is not available profiler UI cannot start.
  If you do not have one, please download it at <a href="#http://java.sun.com/j2se/1.5.0/download.html">http://java.sun.com/j2se/1.5.0/download.html</a>
  </p>
<br/><br/></div><div><a name="running_with_profiler"></a>
<h2 class="faq">1.2&nbsp;&nbsp;Running applications with profiler</h2>

  <p>You can profile applications running Sun Java version 1.3.0 or higher.</p>

  <p>There are different ways to enable profiling in your application.</p>

  <h2>IDE integration</h2>

  <p>
    <a href="#ide_integration">IDE integration</a> provides actions for launching profiling-enabled applications from your IDE.
  </p>

  <h2>Action "Tools | Integrate with J2EE Server..."</h2>

  <p>
    <code class="action">Tools | Integrate with J2EE Server...</code> automatically enables profiling in a number of popular application servers.
  </p>

  <h2>Manual configuration</h2>

  <p>
    <ul>
      <li>Add VM parameter -Xrunyjpagent to the command line of Java application. E.g.:
        <p><code>java -Xrunyjpagent FooClass</code></p>
      </li>
      <li>
        <p><b>Windows:</b> add <i>&lt;YJP Home&gt;</i>\bin\win32 to the PATH</p>
        <p><b>Linux:</b> add <i>&lt;YJP Home&gt;</i>/bin/linux to the LD_LIBRARY_PATH</p>
        <p><b>Linux (outdated, compiled with gcc 2.9):</b> add <i>&lt;YJP Home&gt;</i>/bin/linux-gcc2.9 to the LD_LIBRARY_PATH</p>
        <p><b>Solaris:</b> add <i>&lt;YJP Home&gt;</i>/bin/solaris to the LD_LIBRARY_PATH</p>
      </li>
    </ul>
  </p>

  <p>Read more in <a href="#agent">Agent configuration</a> section...</p>

  <p>Please find samples of configured applications at <a href="../../samples"><i>&lt;YJP Home&gt;</i>\samples</a>.</p>


  <h2>Additional configuration options</h2>

  <p>
    Additional configuration options can be specified either from <a href="#ide_integration">IDE plugin UI</a> or manually with help of <a href="#agent">agent options</a>:
    <ul>
      <li>ability to launch application with started CPU profiling and/or <a href="#allocations">object allocation recording</a></li>
      <li>ability to capture CPU and/or memory snapshots on exit</li>
      <li>alternate directory for snapshots</li>
      <li>alternate agent port</li>
    </ul>
  </p>

<!--
TODO: probably move to FAQ
  <p>
    <b>Hint:</b> If you plan to profile CPU or record object allocation we can suggest to
    specify <code>-Xint</code> JVM command line option to start JVM in interpreted mode.
    Otherwise JVM inlines some methods for optimization purposes, and call traces can mutate -
    inlined methods will not be reported, and the activity of the inlined method will be
    reported as if it happened in the caller of inlined method.
    For example, method HashTable.get() can be inlined.
    The drawback of interpreted mode is that application runs slower.
  </p>
-->
<br/><br/></div><div><a name="agent"></a>
<h2 class="faq">1.2.1&nbsp;&nbsp;Agent configuration</h2>

  <ul>
    <li>
      <p>
      Java Virtual Machine should be able to load the profiler agent. The required actions depend on your OS:
      <p><b>Windows:</b> add <i>&lt;YJP Home&gt;</i>\bin\win32 to the PATH</p>
      <p><b>Linux:</b> add <i>&lt;YJP Home&gt;</i>/bin/linux to the LD_LIBRARY_PATH</p>
      <p><b>Linux (outdated, compiled with gcc 2.9):</b> add <i>&lt;YJP Home&gt;</i>/bin/linux-gcc2.9 to the LD_LIBRARY_PATH</p>
      <p><b>Solaris:</b> add <i>&lt;YJP Home&gt;</i>/bin/solaris to the LD_LIBRARY_PATH</p>
      To check that Java can load the profiler agent, you can invoke the following command that
      prints a description of agent parameters:<br/>
      <code>java -Xrunyjpagent:help</code>
      </p>
    </li>

    <li>
      <p>
      Add Java Virtual Machine parameter <code>-Xrunyjpagent[:&lt;option&gt;, ...]</code>
      to the command line of your application.<br/>
      Options should be separated by comma. The options are:<br/>

      <table cellSpacing="1" cellPadding="1" border="1">
        <tr>
          <td><div><code>sampling</code></div></td>
          <td>
            <div>
              <p>
              Launch Java application with started <a href="#cpu_methods">CPU sampling</a>.
              You can start or stop CPU sampling later from the Profiler or using <a href="#api">Profiler API</a>.
              </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>tracing</code></div></td>
          <td>
            <div>
              <p>
              Launch Java application with started <a href="#cpu_methods">CPU tracing</a>.
              You can start or stop CPU tracing later from the Profiler or using <a href="#api">Profiler API</a>.
              </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>alloc</code></div></td>
          <td>
            <div>
              <p>
              Launch Java application with started <a href="#allocations">object allocation recording</a>.
              You can start or stop allocation recording later from the Profiler or using <a href="#api">Profiler API</a>.
              </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>onexit=cpu</code></div></td>
          <td>
            <div>
              <p>
              Automatically capture CPU snapshot on application exit.
              CPU snapshot will not be captured if on application exit
              neither <a href="#cpu_methods">CPU sampling</a> nor <a href="#cpu_methods">tracing</a> are enabled.
              </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>onexit=memory</code></div></td>
          <td>
            <div>
              <p>
              Automatically capture memory snapshot on application exit.
              </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>onexit=both</code></div></td>
          <td>
            <div>
              <p>
              Automatically capture CPU and memory snapshots on application exit.
              CPU snapshot will not be captured if on application exit
              neither <a href="#cpu_methods">CPU sampling</a> nor <a href="#cpu_methods">tracing</a> are enabled.
              </p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
            <div>
            <code>port=</code><i>&lt;value&gt;</i>
            </div>
          </td>
          <td>
            <div>
            <p>
            Specify port that the profiler agent listens on to communicate with the Profiler.
            By default port <code>10000</code> is used.
            </p>
            </div>
          </td>
        </tr>
        <tr>
          <td>
            <div>
            <code>dir=</code><i>&lt;directory for snapshots&gt;</i>
            </div>
          </td>
          <td>
            <div>
            <p>
            Specify directory where memory and CPU snapshots are created. By default user home directory is used.
            </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>quiet</code></div></td>
          <td>
            <div>
            <p>
            Suppress diagnostics messages that the profiler agent prints to the console.
            </p>
            </div>
          </td>
        </tr>
        <tr>
          <td><div><code>help</code></div></td>
          <td>
            <div>
            <p>
            Print short description of agent parameters.
            </p>
            </div>
          </td>
        </tr>
      </table>


      <br/>
      Examples:<br/>
      <br/>
      <code>java -Xrunyjpagent FooClass</code>
      <br/>
      <code>java -Xrunyjpagent:onexit=memory,dir=c:\MySnapshots FooClass</code>
      </p>
    </li>
  </ul>
<br/><br/></div><div><a name="performance_problems"></a>
<h2 class="faq">2&nbsp;&nbsp;Solution of performance problems</h2>


  <h2>What performance problems could be?</h2>

  <p>
    Memory-related:<br/>
    <ul>
      <li>Application uses more memory than it could</li>
      <li>Memory leaks</li>
      <li>Excessive garbage allocation - application creates a lot of temporarily objects</li>
    </ul>
  </p>

  <p>
    Code-related:<br/>
    <ul>
      <li>Application algorithms are not optimal - there are performance bottlenecks</li>
    </ul>
  </p>
  <br/>
  <br/>

  <h2>Why memory-related issues can be performance problems?</h2>

  <p>
    Memory-related issues affect execution speed and reliability of application:
    <ul>
      <li>
        When Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made
        available by the garbage collector, OutOfMemoryError is thrown, which can cause application crash or further unstable work.
      </li>
      <li>
        Application that uses a lot of memory reduces available physical memory for itself and other programs
        and forces operating system to swap memory pages to and from disk more frequently, which leads to serious overall system performance degradation.
      </li>
      <li>
        Java Virtual Machine spends more time to perform garbage collection when more objects exist and more temporarily objects are created.
      </li>
    </ul>
  </p>
  <br/>
  <br/>

  <h2>How to find why application eats that much memory?</h2>

  <p>
    <ul>
      <li><a href="#running_with_profiler">Run profiling-enabled application</a>.</li>
      <li>Connect to application from "Control Panel". Hint: DO NOT <a href="#allocations">record allocations</a> as they are not needed to solve this task.</li>
      <li>Capture and open memory snapshot.</li>
      <li>Use <a href="#objects_view_stat">Class tree</a> in the "All Objects".</li>
    </ul>
  </p>
  <br/>
  <br/>

  <h2>How to find memory leak?</h2>

  <p>
    <i>Memory leak</i> - object(s) that are not needed anymore according to the logic of application,
    but still retain memory and cannot be collected because they are referenced from other live objects
    due to a bug in application.
  </p>

  Your steps could be:
  <ol>
    <li>
      Detect memory leak, i.e. understand <i>what</i> objects do exist but should not.<br/>

      <p>
        If you <b>do not know yet what objects are leaked</b>, profiler can help to find it out.
      </p>

      <p>
        You can <a href="#compare_snapshots">compare memory snapshots</a>, one of which represents
        memory state without leak, and another - already with leak, and easily find leaked objects.
      </p>

      <p>
        You can also analyse single snapshot with help of <a href="#objects_view">Statistics section of Objects view</a> to find how memory is distributed between
        instances of different classes.
      </p>

      <p>
        Often potential leaks in particular profiled application are <b>already well known</b> e.g. you know class of objects that have "tendency" to
        leak while application is being developed, changed, refactored.
        It's easy to check presence of such objects with help of <code class="action">View | Instances by Class... (Ctrl+N or from popup menu)</code>.
        In more complex cases you can use <a href="#language">Set description language</a> to declare sets of potentially leaked objects.
      </p>

      <p>
        Note that even one class can have objects legally and illegally (leaked objects) retained in memory.
        To distinct them, you can use <a href="#objects_view_explorer">objects explorer</a> to see outgoing or incoming references. For example,
        object can have a field that references a human-readable String identifier.
      </p>
    </li>
    <li>
      <p>
      Once you have found leaked object(s), it's time to understand why they retain in memory.
      Having leaked object(s) selected in a memory view, use <code class="action">Find | Paths from GC Roots... (Ctrl+P)</code>.
      See <a href="#paths">Working with paths</a> for details.
      </p>

      <p>
        Hint: Browsing paths, use <a href="#ide_integration_navigation">navigation</a> feature of IDE integration.
      </p>
    </li>
  </ol>
  <br/>
  <br/>

  <h2>How to find excessive garbage allocation?</h2>

  <p>
  Purpose: reduce time garbage collector spends to collect temporarily objects.
  </p>

  <p>
  Let's assume there's a <i>task</i> in your application that you want to profile.
  </p>

  <ul>
    <li><a href="#running_with_profiler">Run profiling-enabled application</a>.</li>
    <li>Connect to application from "Control Panel".</li>
    <li>Start to <a href="#allocations">record allocations</a> right before the start of the <i>task</i>.</li>
    <li>Wait until the <i>task</i> finishes or performs long enough.</li>
    <li>Capture memory snapshot and stop allocation recording.</li>
    <li>Open snapshot and use <a href="#garbage">Garbage</a> view.</li>
  </ul>
  <br/>
  <br/>

  <h2>How to find performance bottleneck via CPU profiling?</h2>

  <p>
  Let's assume there's a <i>task</i> in your application that you want to profile.
  </p>

  <ul>
    <li><a href="#running_with_profiler">Run profiling-enabled application</a>.</li>
    <li>Connect to application from "Control Panel".</li>
    <li>Choose profiling <a href="#cpu_methods">method</a> and start profiling right before the start of the <i>task</i>.</li>
    <li>Wait until the <i>task</i> finishes or performs long enough.</li>
    <li>Capture CPU snapshot and open it.</li>
    <li>Use <a href="#cpu_stat">CPU Statistics view</a>.</li>
  </ul>

        <!--
        example - String concat in loop...
        Better use stringbuffer
        -->
<br/><br/></div><h2>3&nbsp;&nbsp;CPU profiling</h2><br/><div><a name="cpu_howto"></a>
<h2 class="faq">3.1&nbsp;&nbsp;How to profile CPU</h2>

  <p>First of all, <a href="#running_with_profiler">enable profiling</a> of your application.</p>

  <p>
  To begin CPU profiling start <a href="#cpu_methods">sampling</a> or <a href="#cpu_methods">tracing</a>.
  When you finish with the profiled task of your application, capture CPU snapshot and analyse it in the profiler.
  </p>

  <p>
  You can perform these actions from the Control Panel, or via <a href="#api">Profiler API</a>.
  In some cases instead of starting CPU profiling manually you may want to launch application with CPU profiling started (see <a href="#running_with_profiler">Running applications with Profiler</a>).
  </p>

  <p>
  You can start and stop CPU profiling during execution of your application as many times as you wish.
  When CPU profiling is not started, profiler adds no performance overhead to application being profiled.
  </p>
<br/><br/></div><div><a name="cpu_methods"></a>
<h2 class="faq">3.2&nbsp;&nbsp;Methods of CPU profiling</h2>

  There are two methods of CPU profiling available: <i>sampling</i> and <i>tracing</i>.
  Both have pros and cons, and in different cases one can suit better than another.

  <h2>Sampling</h2>

  <p>Sampling periodically inquires the call stacks of all threads in order to approximate method times.</p>

  <p>Sampling has minimal performance overhead, but it measures approximate CPU times
  and no method invocation counts are available.
  </p>

  <p>Sampling would be the best choice in most cases.</p>

  <h2>Tracing</h2>

  <p>Tracing processes all method invocations and measures time spent by thread between method entry
  and method exit.</p>

  <p>Tracing accurately records method times and invocation counts, but it can noticeably slow down application being profiled.
  The higher the number of method invocations, the lower the speed.
  </p>

  <p>Use tracing when accuracy of sampling is not satisfactory or you need to count method invocations.</p>

  <p>
    Also due to a known JVM bug under some conditions profiled methods can continue to run slower
    even when tracing is already turned off, and we do not recommend to use tracing in production environment.
  </p>
<br/><br/></div><div><a name="cpu_stat"></a>
<h2 class="faq">3.3&nbsp;&nbsp;CPU Statistics view</h2>

  <p>
    CPU Statistics view (<code class="action">View | CPU Statistics</code>) shows overall CPU consumption information.
  </p>
  <p>
    The view consists of 3 sections:
  </p>

  <ul>
    <li>
      <p>
        <b>Hot spots</b>
        <p>
          Shows methods that consumed the most CPU. Only methods accepted with <a href="#filters">current filters</a> are included.
          For each hot spot method its merged callees are shown.
        </p>
      </p>
    </li>
    <li>
      <p>
        <b>Invocation tree (all threads together)</b>
        <p>
          Shows top-down call tree with calls from all threads merged.
        </p>
      </p>
    </li>
    <li>
      <p>
        <b>Invocation tree (by threads)</b>
        <p>
          Shows top-down call tree for each thread.
        </p>
      </p>
    </li>
  </ul>

  <p>
    The shown method times are cumulative, i.e. include time spent in methods called from a method.
  </p>

  <p>
    If CPU was profiled with <a href="#cpu_methods">tracing</a>, method invocation counts are shown in invocation trees as well.
    Invocation counts are not cumulative.
  </p>

  <p>
    You can apply the following actions to the selected method (available from popup menu as well):
    <ul>
      <li>
        <code class="action">View | Method (Ctrl+M)</code> - <a href="#cpu_method_view">view merged callees, back traces and all invocation points</a>
      </li>
      <li>
        <code class="action">Tools | Open Declaration in IDE Editor (F7)</code> - open method declaration
        in IDE editor (see <a href="#ide_integration">IDE integration</a>).
      </li>
    </ul>
  </p>
<br/><br/></div><div><a name="cpu_method_view"></a>
<h2 class="faq">3.4&nbsp;&nbsp;Method view</h2>

  <p>
    This view shows for a particular method its merged callees, back traces and all invocation points.
  </p>

  <p>
    <code class="action">View | Method (Ctrl+M or from popup menu)</code> opens this view for a selected method.
  </p>
  <p>
    <code class="action">View | Method by Name...(Ctrl+Shift+M or from popup menu)</code> opens this view for a method with given name.
  </p>

  <h2>Merged callees</h2>

  <p>
    Shows merged all call traces started from the method.
    This gives a summury of method execution, of its "overall" behaviour.
  </p>

  <h2>Back traces</h2>

  <p>Shows where the method was called from.</p>

  <h2>Invocation points</h2>

  <p>
    Shows all points in all threads where the method was invoked. The method is visually marked.
  </p>

  <br/>
  <br/>
  <br/>
  <p>
    If CPU was profiled with <a href="#cpu_methods">tracing</a>, method invocation counts are shown in invocation trees as well.
    Invocation counts are not cumulative.
  </p>

  <p>
    You can apply the following actions to the selected method (available from popup menu as well):
    <ul>
      <li>
        <code class="action">View | Method (Ctrl+M)</code> - view selected method
      </li>
      <li>
        <code class="action">Tools | Open Declaration in IDE Editor (F7)</code> - open method declaration
        in IDE editor (see <a href="#ide_integration">IDE integration</a>).
      </li>
    </ul>
  </p>
<br/><br/></div><div><a name="cpu_snapshot_properties"></a>
<h2 class="faq">3.5&nbsp;&nbsp;CPU snapshot properties</h2>

  <p>
    To display snapshot properties use <code class="action">File | Snapshot Properties...</code> in main menu or
    invoke popup menu right clicking on the tab with snapshot name.
  </p>

  <p>
    CPU snapshot Properties dialog displays snapshot information summary.
  </p>

  <p>
    If profiled application is obfuscated profiler can automatically restore
    original names of classes and methods if you specify path to the obfuscation log file.
  </p>
<br/><br/></div><h2>4&nbsp;&nbsp;Memory profiling</h2><br/><div><a name="memory_snapshots"></a>
<h2 class="faq">4.1&nbsp;&nbsp;Snapshots</h2>

  <p>
    Memory snapshot represents memory state of profiled application at the moment of capture.
    It contains information about all classes loaded by JVM, about all existing objects and
    references between objects. Optionally snapshot can contain information about
    object <a href="#allocations">allocations</a>.
  </p>

  <p>
    Current implementation does not contain information about values of primitive types.
    In practice this information is not needed for tasks such as memory leak detection and memory distribution
    analysis. On other hand this approach dramatically reduces the size of snapshot files, so snapshots are
    saved faster and profiler needs less memory to load snapshots.
    Instead, values of strings are saved in order to find (identify) particular object through other
    objects of the same class. Profiler can search for strings, even with regular expressions.
  </p>

  <p>
    When snapshot is opened in profiler the objects that are not referenced and thus can be collected are
    treated as collected. It is also assumed that all weak and soft references are nulled, and the objects accessible
    only by weak or soft references are treated as collected. This simplifies
    memory leak detection helping to focus on the real, "hard referenced" problems.
  </p>

  <p>
    In a very special case you may want to keep week/soft references. To achieve it, please specify
    properties <code>'-Dyjp.keep.weak.refs=true'</code> and/or <code>'-Dyjp.keep.soft.refs=true'</code>.
    In Windows, pass them as parameters of <code>yjp.exe</code> e.g. <code>'yjp -Dyjp.keep.soft.refs=true -Dyjp.keep.weak.refs=true'</code>.
    In Linux or Solaris please patch the command line in <code>yjp.sh</code>.
    Please note that these are experimental options and we can drop them in future releases.
  </p>

<br/><br/></div><div><a name="allocations"></a>
<h2 class="faq">4.2&nbsp;&nbsp;Allocation recording</h2>

  <p>
    Profiler can optionally record object allocations, i.e. track method call stacks where objects are created.
    Memory snapshot captured when allocations are being recorded contains allocation information.
    If object was created when allocations were not being recorded, or recording was stopped at least once
    after object has been created, snapshot will contain no allocation information for that object.
  </p>

  <p>
    Recording of allocations adds performance overhead. This is the reason why allocations
    should not be recorded always. Instead you can record allocations when you need it.
  </p>

  <p>
    You can control recording of allocations in the Control Panel, or via <a href="#api">Profiler API</a>.
    You can also record allocations from the start of application execution
    (see <a href="#running_with_profiler">Running applications with Profiler</a>).
  </p>

  <p>
    You can start and stop recording of allocations during execution of your application as many times as you wish.
    When allocations are not recorded, memory profiling adds no performance overhead to application being profiled.
  </p>
<br/><br/></div><div><a name="sizes"></a>
<h2 class="faq">4.3&nbsp;&nbsp;Shallow and retained sizes</h2>


  <p>
    <b>Shallow size</b> of object is the memory allocated to store the object itself, disregarding the referenced
    objects. Shallow size of a regular (non-array) object depends on the number and types of
    its fields. Shallow size of array depends on array length and type of stored elements (objects, primitive types).
    Shallow size of object set is the sum of shallow sizes of each object.
  </p>

  <p>
    <b>Retained size</b> of set of objects is the memory that will be freed by garbage collector if all
    the objects of the set are collected. Let's call the set that will be freed retained set.
    In other words, retained size of set of objects is the shallow size
    of the set itself plus shallow size of all the objects that do not belong to the set and are accessible by
    references from and only from the objects of the set.
  </p>

  <p>
    Please note that, unlike shallow size, retained size of set of objects is not always the sum of retained sizes
    of each object.
  </p>

  <p>
    More formal:
  </p>
  <ul>
    <p>
      Objects in memory are nodes of graph, and references from objects to objects are its edges. There are special
      nodes - GC roots objects.
    </p>
    <p>
      "Retained Set" with given base nodes <i>B</i> is the maximal subgraph <i>R</i> of entire graph so that:
    </p>
    <p>
      <ol>
        <li>
          <i>R</i> includes the base nodes <i>B</i>.
        </li>
        <li>
          <i>R</i> can include nodes <i>Q</i> that are not from <i>B</i>. For each node <i>q</i> from <i>Q</i> there
          should be at least one path from roots that contains any node from <i>B</i>,
          and should be no path from roots that contains no node from <i>B</i>.
        </li>
      </ol>
    </p>
  </ul>
  <p>
    The picture below shows objects forming retained set with base node
    object 1. The retained set contains objects 1, 2 and 4. Objects 3 and 5 do not belong to the retained set of object 1
    because there are paths from GC roots to them that do not go through object 1.
    <p>
    <center>
    <img src="images/retained-objects.png" align="middle" alt=""/>
    </center>
    </p>
  </p>
  <p>
    Retained size of objects is the shallow size of all objects of their retained
    set. Obviously retained size of any base set is greater or equal than its shallow size, because it always
    contains entire base set. Retained size is an integral measure, that helps to
    understand structure (clusterization) of memory, the dependences between object subgraphs and
    find potential roots of that subgraphs.
  </p>
<br/><br/></div><h2>4.4&nbsp;&nbsp;Memory views</h2><br/><div><a name="objects_view"></a>
<h2 class="faq">4.4.1&nbsp;&nbsp;Objects view</h2>

  <h2>Purpose</h2>
  <p>
    Allows comprehensively examine a set of objects.
  </p>

  <h2>How can be opened</h2>
  <p>
    <ul>
      <li>Tab "All Objects" opens automatically on memory snapshot opening and represents all live objects.</li>
      <li><code class="action">View | Selected Objects (F4)</code> works in any memory view if selection represents live objects.</li>
      <li><code class="action">View | Instances by Class... (Ctrl+N)</code> opens all instances of a class by its name.</li>
      <li><code class="action">Find | Strings by Pattern... (Ctrl+F)</code> opens instances of <code>java.lang.String</code> that match given pattern.</li>
      <li><code class="action">View | Predefined Set...</code> opens objects that belong to one of sets specified in <code class="action">Settings | Sets of Objects...</code>.</li>
    </ul>
  </p>

  <h2>The sections provide different 'views' of the set:</h2>

  <p>
    <a href="#objects_view_stat">Statistics</a> - analyse object counts and retained memory size
  </p>
  <p>
    <a href="#objects_view_explorer">Object Explorer</a> - browse individual objects
  </p>
  <p>
    <a href="#objects_view_alloc_hot_spots">Allocation hot spots</a> - methods where most of objects from the set
    were created (available only if snapshot contains recorded <a href="#allocations">object allocations</a>).
  </p>
  <p>
    <a href="#objects_view_alloc_tree">Allocation call tree</a> -  top-down call tree with methods where objects from
    the set were created (available only if snapshot contains recorded <a href="#allocations">object allocations</a>).
  </p>

<br/><br/></div><div><a name="objects_view_stat"></a>
<h2 class="faq">4.4.1.1&nbsp;&nbsp;Statistics</h2>

  <b>Class tree</b>

  <p>
    This view is a powerful tool for examining how memory is distributed
    among instances of different classes. The benefit of the view is that information about instances is grouped
    by packages and classes. Actually, the goal of analysis is to find out which subsystem of the
    profiled application consumes the most of the memory, causes memory leak etc. Because packages usually represent
    subsystems, the good measure of memory retained by subsystem is the memory retained by objects of classes that
    belong to subsystem's package.
  </p>

  <p>
    Information for each tree node is shown in four columns "Name", "Objects" (number of objects), "Shallow Size" and "Retained Size".
  </p>

  <p>
    Tree nodes can be package, class or instance field.
  </p>

  <p>
    <i>Package node</i> <img src="images/package.png" align="middle" alt=""/> represents objects that are instances of all classes (without subclasses)
    of the package including subpackages.
  </p>
  <p>
    <i>Class node</i> <img src="images/class.png" align="middle" alt=""/> represents all instances of the class (not including instances of subclasses).
  </p>
  <p>
    <i>Field node</i> represents all objects retained by and only by this field in instances of the class.
    In other words, the shown objects are those that will be freed should the field be nulled in all the class instances.
    This helps to learn whether a particular field is the reason of memory retention.
  </p>

  <b>Class list</b>

  <p>
    Shows number and shallow sizes for objects of all or only particular classes if filter is specified.
  </p>

  <p>
    Note: Filter below the Class list is not related with the <a href="#filters">filters</a> configured
    via <code class="action">Settings | Filters...</code> and applies only to this view.
  </p>

  <p>
    "Class list" doesn't show retained sizes because they would take too much time to calculate for an entire list
    of all classes.
    Use "Class tree" instead if you need more information about memory consumption than a rough estimation
    of object counts.
  </p>
<br/><br/></div><div><a name="objects_view_explorer"></a>
<h2 class="faq">4.4.1.2&nbsp;&nbsp;Object Explorer</h2>

  <b>Outgoing references</b>

  <p>
    Shows all objects of the set and allows to browse their outgoing references.
    Outgoing references of an object are fields or array elements of that object that point to other objects.
  </p>

  <p><center><img src="images/outgoing-ref-explorer.gif" align="middle" alt=""/></center></p>

  <br/>

  <b>Incoming references</b>

  <p>
    Shows all objects of the set and allows to browse their incoming references.
    Incoming references of an object are references to that object.
  </p>

  <p>
    Hint: DO NOT use 'Incoming references' to find why object retains in memory - automatically <a href="#paths">find paths</a> instead.
  </p>

  <p><center><img src="images/incoming-ref-explorer.gif" align="middle" alt=""/></center></p>
<br/><br/></div><div><a name="objects_view_alloc_hot_spots"></a>
<h2 class="faq">4.4.1.3&nbsp;&nbsp;Allocation hot spots</h2>

  <p>
    This section is available only if snapshot contains recorded <a href="#allocations">object allocations</a>.
  </p>

  <p>
    <b>By object count</b>
    <p>
      Shows methods where biggest number of objects from the set was created.
    </p>
  </p>

  <p>
    <b>By object size</b>
    <p>
      Shows methods where objects from the set with biggest total shallow size were created.
    </p>
  </p>

  For each hot spot method its merged callees are shown.
<br/><br/></div><div><a name="objects_view_alloc_tree"></a>
<h2 class="faq">4.4.1.4&nbsp;&nbsp;Allocation call tree</h2>

  <p>
    This section is available only if snapshot contains recorded <a href="#allocations">object allocations</a>.
  </p>

  <p>
    <b>All threads together</b>
    <p>
      Shows top-down call tree with calls with methods where objects from the set were created. Calls from all threads are merged.
    </p>
  </p>

  <p>
    <b>By threads</b>
    <p>
      Shows a per-thread top-down call trees with methods where objects from the set were created.
    </p>
  </p>
<br/><br/></div><div><a name="garbage"></a>
<h2 class="faq">4.4.2&nbsp;&nbsp;Garbage view</h2>

  <p>
    This view is available only if snapshot contains recorded <a href="#allocations">object allocations</a>.
  </p>

  <p>
    This view is a good starting point to search for excessive garbage allocation. It shows numbers and shallow sizes of collected objects,
    i.e. objects created since <a href="#allocations">allocation recording</a> was started and recycled to the moment of snapshot capture.
    See <a href="#performance_problems">Solution of performance problems</a> to learn more why one should avoid excessive garbage allocation.
  </p>

  <h2>Allocation hot spots</h2>

  <p>
    <b>By object count</b>
    <p>
      Shows methods where biggest number of collected objects was created.
    </p>
  </p>

  <p>
    <b>By object size</b>
    <p>
      Shows methods where collected objects with biggest total shallow size were created.
    </p>
  </p>

  For each hot spot method its merged callees are shown.

  <h2>Allocation call tree</h2>

  <p>
    <b>All threads together</b>
    <p>
      Shows top-down call tree with calls from all threads merged with methods where collected objects were created.
    </p>
  </p>

  <p>
    <b>By threads</b>
    <p>
      Shows top-down call tree for each thread with methods where collected objects were created.
    </p>
  </p>
<br/><br/></div><div><a name="mem_method_view"></a>
<h2 class="faq">4.4.3&nbsp;&nbsp;Method view</h2>

  <p>
    This view is available only if snapshot contains recorded <a href="#allocations">object allocations</a>.
  </p>
  <p>
    This view shows for a particular method that allocated objects its merged callees, back traces and all invocation points.
  </p>

  <p>
    <code class="action">View | Method (Ctrl+M or from popup menu)</code> opens this view for a selected method.
  </p>
  <p>
    <code class="action">View | Method by Name...(Ctrl+Shift+M or from popup menu)</code> opens this view for a method with given name.
  </p>

  <h2>Merged callees</h2>

  <p>
    Shows merged all call traces started from the method.
    This gives a summury of method execution, of its "overall" behaviour.
  </p>

  <h2>Back traces</h2>

  <p>Shows where the method was called.</p>

  <h2>Invocation points</h2>

  <p>
    Shows all points in all threads where the method was invoked. The method is visually marked.
  </p>
<br/><br/></div><div><a name="gc_roots"></a>
<h2 class="faq">4.4.4&nbsp;&nbsp;GC roots view</h2>

  <p>
    There are objects special for garbage collector, so called GC (garbage collector) roots.
    Garbage collector collects the objects that are not GC roots and are not accessible by references from GC roots.
  </p>

  <p>
    There are following types of GC roots:
  <ul>
    <li>Objects referenced from static fields of loaded classes.</li>
    <li>Objects accessible from stacks of threads, i.e. accessible from local variables.</li>
    <li>Objects passed as parameters to JNI calls.</li>
    <li>Objects accessible by global JNI references.</li>
    <li>Objects used as monitors for threads synchronization.</li>
    <li>Objects accessible from native stack.</li>
  </ul>
  </p>

  <p>
    "GC Roots" view shows garbage collector roots sorted by types as well as all loaded classes and classes with static fields.
  </p>

  <p>
    Note that snapshots created under JDK 1.3.x all GC roots are reported by JVM as Unknown
    and thus cannot be sorted in the "GC Roots" view.
  </p>

  <p>
    <i>Memory leak</i> is an existence of object(s) that are not needed anymore according to the logic of application,
    but still retain memory and cannot be collected because they are referenced from other live objects
    due to a bug in application.
    <br/>
    Obviously, each leaked object is accessible from at least one GC root or is a GC root. In other words, for each leaked object
    always there is a path that starts from GC roots and contains (ends with) the leaked object.
  </p>

  <p>
    "GC Roots" view is not the place to start leak detection - see <a href="#paths">Working with paths</a> for
    a better approach.
    Instead "GC Roots" allows to get an overview of all objects that could not be collected at moment
    when snapshot was created.
  </p>

<br/><br/></div><div><a name="paths"></a>
<h2 class="faq">4.4.5&nbsp;&nbsp;Working with paths</h2>

  <p>
  YourKit Java Profiler has unique and very powerful means for memory leak detection -
  calculation of <i>paths</i> between objects in memory.
  Path is a very simple and intuitive concept. Path between Object 1 and Object 2
  is a sequence of objects so that:
  </p>

  <ul>
    <li>First element of sequence is Object 1</li>
    <li>Each element of sequence, starting from second one, is referenced from its predecessor</li>
    <li>Last element of sequence references Object 2</li>
  </ul>

  <p>YourKit Java Profiler has two actions to search paths:</p>

  <ul>
    <li>
      Select an object and invoke <code class="action">Find | Paths from GC Roots... (Ctrl+P)</code> action
      to find out why the selected object is retained in memory. This action is needed when you
      have found a leaked object and want to fix memory leak.
    </li>
    <li>
      <code class="action">Find | Paths between Predefined Sets...</code> is the most common way to find how any object of source set
      references objects of target set.
    </li>
  </ul>

  <p>Let's show with a simple example how to use paths.</p>
  <ul>
    <p>
    Assume that we profile an Editor application that can open, edit and close text files.
    Imagine there's a singleton object that acts as manager of opened files,
    and data of each opened file is represented with instance of class <i>Document</i>.
    </p>

    <p>
    During profiling session we open several text files, edit them, close them and take a memory snapshot.
    </p>

    <p>
    If everything is good, there should be no instances of <i>Document</i> that cannot be collected.
    So, first of all use <code class="action">View | Instances by Class... (Ctrl+N)</code> to see if there are leaked <i>Document</i>s.
    </p>

    <p>
    Assume we have found such objects - it's a leak. There should be paths from GC roots to them (or some of them are among GC
    roots themselves - it will be indicated in the view).
    </p>

    <p>
    Then we find paths from GC roots to one of the <i>Documents</i> (Ctrl+P), or to all the <i>Documents</i> defining
    the set.
    If all paths go through the manager singleton, the code that should close files in editor must have a bug.
    If none of the paths contains the manager singleton, looks like closing works good, but there are object(s)
    in the path(s) that mistakenly hold references to <i>Documents</i> and cause the memory leak.
    </p>
  </ul>

  <p>Find paths actions allow to limit the number of paths to find. It is guaranteed that shortest paths are found first,
  so there are no paths shorter than the displayed ones.</p>

  <p>
    If search takes a long time, you can cancel it or stop it with means of corresponding buttons
    "Cancel" and "Stop".
    Note that "Cancel" totally cancels search operation. "Stop" interrupts search and allows to
    see paths that could be already found up to the moment when you press the button.
  </p>
<br/><br/></div><div><a name="compare_snapshots"></a>
<h2 class="faq">4.5&nbsp;&nbsp;Ability to compare snapshots</h2>

  <p>
    You can compare two memory snapshots captured during the same launch of profiled application.

    <p>
      This can help to locate memory leaks.
    </p>


    <p>
      To compare snapshots, use the following scenario:
      <ul>
        <li>Connect to running application in "Control Panel".</li>
        <li>Capture memory snapshot (Snapshot 1). You may skip its opening then.</li>
        <li>Let the application perform operation that as you think causes a memory leak.</li>
        <li>Capture memory snapshot (Snapshot 2) and open it.</li>
        <li>Use <code class="action">File | Compare Snapshot with...</code> action (also available from popup menu)
            and choose Snapshot 1 in the file chooser.
        </li>
      </ul>
    </p>
    <p>
      Indeed all views are similar to ones of opened alone Snapshot 2 except for an additional "New Objects" tab
      (opened automatically or with <code class="action">View | New Objects</code>) which is similar to <a href="#objects_view">Objects view</a>
      with these exceptions:
      <ul>
        <li>
          "Class tree" and "Class list" have 2 additional columns,
          Objects (+/-) and Size (+/-), that display difference in object counts and sizes. Positive values mean that
          Snapshot 2 (the later memory state) has more objects or objects have bigger size.
        </li>
        <li>
          "Class tree" and "Class list" show counts and sizes for <i>new objects</i> only.
          <i>New objects</i> are those live objects from Snapshot 2 that did not exist at the moment when Snapshot
          1 was captured.
        </li>
      </ul>
    </p>

    <p>
      <a href="#memory_actions">Actions</a> that work on current selection such as <code class="action">View | Selected Objects (F4)</code>
      or <code class="action">Find | Paths from GC Roots... (Ctrl+P)</code> take into account only new objects.
    </p>

    <p>
      Please note that:
      <ul>
        <li>
          If memory leak indeed happened after Snapshot 1 and before Snapshot 2 were captured,
          leaked objects should be through the <i>new objects</i>.
        </li>
        <li>
          Not every <i>new object</i> is a leak - it's just a hint about object's "age". Objects can normally
          be created, used and then collected.
          To find leak, you should take into account not only the number of new objects, but also the differences in
          counts and sizes, i.e. check whether the number of objects increased.
        </li>
      </ul>
    </p>
  </p>
<br/><br/></div><div><a name="memory_actions"></a>
<h2 class="faq">4.6&nbsp;&nbsp;Useful actions</h2>

  Hint: probe popup and main menu to see what actions are enabled in a particular context.

  <ul>
    <li>
      <p>
        <code class="action">View | Quick Info (Ctrl+Q or from popup menu)</code> - shows <a href="#sizes">retained and shallow size</a>
        and object count for the current selection. If single object is selected, its allocation trace is shown if available.
        Works in any memory view if selection represents live objects.
      </p>
    </li>
    <li>
      <p>
        <code class="action">View | Instances by Class... (Ctrl+N or from popup menu)</code> -
        <a href="#objects_view">shows</a> instances of a class given its name.
        Hint: also use this action to find the number of instances of particular class: type in class name, read shown instance count and then hit ESC to
        avoid opening of new tab if it is not desired.
      </p>
    </li>
    <li>
      <p>
        <code class="action">View | Selected Objects (F4 or from popup menu)</code> -
        <a href="#objects_view">shows</a> selected live objects in a new tab.
        Works in any memory view if selection represents live objects.
      </p>
    </li>
    <li>
      <p>
        <code class="action">Find | Paths from GC Roots... (Ctrl+P or from popup menu)</code> - finds <a href="#paths">paths</a>
        from GC roots to objects represented with current selection.
        Works in any memory view if selection represents live objects.
      </p>
    </li>
    <li>
      <p>
         <code class="action">Find | Strings by Pattern... (Ctrl+F)</code> -
         <a href="#objects_view">shows</a> instances of <code>java.lang.String</code> that match given pattern.
         This can be useful to locate particular objects if their fields refer to a known string.
      </p>
    </li>
    <li>
      <p>
        <code class="action">Tools | Open Declaration in IDE Editor (F7)</code> - opens currently selected class, field or method in IDE editor.
        See <a href="#ide_integration">IDE integration</a>.
      </p>
    </li>
  </ul>

  The following actions are available if snapshot contains recorded <a href="#allocations">object allocations</a>:

  <ul>
    <li>
      <p>
        <code class="action">View | Method (Ctrl+M or from popup menu)</code> -
        <a href="#mem_method_view">view merged callees, back traces and all invocation points</a> of a selected method.
      </p>
    </li>
    <li>
      <p>
        <code class="action">View | Method by Name...(Ctrl+Shift+M or from popup menu)</code> -
        <a href="#mem_method_view">view merged callees, back traces and all invocation points</a> of a method with given name.
      </p>
    </li>
  </ul>
<br/><br/></div><div><a name="memory_snapshot_properties"></a>
<h2 class="faq">4.7&nbsp;&nbsp;Memory snapshot properties</h2>

  <p>
    To display snapshot properties use <code class="action">File | Snapshot Properties...</code> in main menu or
    invoke popup menu right clicking on the tab with snapshot name.
  </p>

  <p>
    Memory snapshot Properties dialog displays snapshot information summary.
  </p>

  <p>
    If profiled application is obfuscated profiler can automatically restore
    original names of classes, fields and methods if you specify path to the obfuscation log file.
  </p>
<br/><br/></div><div><a name="language"></a>
<h2 class="faq">4.8&nbsp;&nbsp;Set description language</h2>

  <p>
    This XML-based language provides advanced ability to specify sets of objects
    in a declarative way. It can be used for e.g. examination of memory distribution in automated memory tests.
  </p>

  <p>
    To find some examples please go to <code class="action">Settings | Sets of Objects...</code> in the main menu.
    Action <code class="action">View | Predefined Set...</code> allows to open sets defined in <code class="action">Settings | Sets of Objects...</code>.
  </p>

  <ul>

  <li>
    <p>Tag <b>objects</b> specifies objects of particular class(es).</p>

    <p>Mandatory attribute <b>class</b> specifies full qualified class name. Wildcards are accepted (*).</p>

    <p>Optional attribute <b>subclasses</b> specifies whether subclasses should be accepted (<i>subclasses="true"</i>)
    or class should match exactly (<i>subclasses="false"</i>). Default value is <i>true</i>.
    </p>

    <p>Examples:</p>

    <p>
    &lt;objects class="com.company.MyClass"/&gt; - all instances of the class com.company.MyClass and its subclasses
    </p>

    <p>
    &lt;objects class="com.company.MyClass" subclasses="false"/&gt; - all instances of
      com.company.MyClass excluding instances of classes derived from com.company.MyClass
    </p>

    <p>&lt;objects class="*[]"/&gt; - all arrays</p>
  </li>

  <li>
    <p>Tag <b>roots</b> specifies all objects that are GC roots</p>
    <p>Example:</p>
    <p> &lt;roots/&gt; </p>
  </li>

  <li>
    <p>Tag <b>and</b> intersects specified sets and as the result returns all objects that present in each of the sets.
    There should be at lease 2 nested sets.</p>

    <p>Example:</p>

    <p> The specification of all objects of classes that implement both com.company.MyInterfaceA and
     com.company.MyInterfaceB interfaces: </p>

    <pre>
  &lt;and&gt;
    &lt;objects class="com.company.MyInterfaceA"/&gt;
    &lt;objects class="com.company.MyInterfaceB"/&gt;
  &lt;/and&gt;
    </pre>
  </li>

  <li>
    <p>Tag <b>or</b> joins specified sets and as the result returns all objects that present at least in one of the sets.
    There should be at least 2 nested sets.</p>

    <p>Example:</p>

    <p> The specification of all objects of class com.company.A and its subclasses, and
    all objects of class com.company.B and its subclasses: </p>

    <pre>
  &lt;or&gt;
    &lt;objects class="com.company.A"/&gt;
    &lt;objects class="com.company.B"/&gt;
  &lt;/or&gt;
    </pre>
  </li>

  <li>
    <p>Tag <b>not</b> specifies all objects that not present in the specified set.
    There should be one and only one set specified.</p>

    <p>Example:</p>

    <p>The specification of all objects except for the objects of class com.company.A and its subclasses:</p>

    <pre>
  &lt;not&gt;
    &lt;objects class="com.company.A"/&gt;
  &lt;/not&gt;
    </pre>
  </li>

  <li>
    <p>Tag <b>reachable-objects</b> specifies objects accessible by references from set specified
      via mandatory subtag <b>from</b>.
    </p>

    <p>
    The result will not include objects other than
    the ones specified via mandatory subtag <b>object-filter</b>.
    In terms of graphs, <b>object-filter</b> specifies allowed nodes.
    </p>

    <p>
    Mandatory subtag <b>field-filter</b> allows to search for objects reachable only from particular fields of
    classes.

    Restrictions for any number of classes can be specified as <b>class</b> subtags of <b>field-filter</b>:

    <pre>
  &lt;field-filter&gt;
    &lt;class name="com.company.ClassA"&gt;
      &lt;allowed field="field1"/&gt;
      ...
      &lt;forbidden field="field2"/&gt;
      ...
    &lt;/class&gt;
    &lt;class name="com.company.ClassB"&gt;
      ...
    &lt;/class&gt;

    ...

  &lt;/field-filter&gt;</pre>
    <p>
    For each class you can specify any number of names (including 0) of <b>allowed</b> and <b>forbidden</b> fields.
    If at least one <b>allowed</b> tag is specified, only the <b>allowed</b> fields will be allowed for the class.
    If no <b>allowed</b> fields are specified, any fields except for the <b>forbidden</b> ones will be allowed for the class.
    </p>

    <p> Any fields of classes not specified in <b>field-filter</b> are acceptable.</p>

    </p>

    <p>Example:</p>

    <p>
    The following example is a predefined set "Lost UI" (see <code class="action">Settings | Sets of Objects...</code>).
    It allows to find all AWT/Swing UI controls that are not in the window hierarchy.
    </p>

    <p>
    UI controls are instances of <i>java.awt.Component</i> and subclasses.
    Class <i>java.awt.Container</i> is a subclass of <i>java.awt.Component</i> and represents controls that contain other controls.
    To be showing, control must be contained in windows, represented with objects of class
    <i>java.awt.Window</i> with subclasses; <i>java.awt.Window</i> extends <i>java.awt.Container</i>.
    </p>

    <p>
    Our goal is to find any UI control (i.e. instance of <i>java.awt.Component</i>) not accessible
    from window hierarchy. So we start from windows (see <b>from</b> section).
    </p>

    <p>
    We know that <i>java.awt.Container</i> stores its children in field named <i>component</i> which is an array of
    components. According to this we form <b>object-filter</b> and <b>field-filter</b> sections.
    Note that we have to include <i>java.awt.Component[]</i> to the object filter, so the result of entire
    <b>reachable-objects</b> tag will include arrays of components as well as components.
    </p>

    <p>
    To complete the task, we use combination of <b>and</b> and <b>not</b> to retrieve components that are not
    accessible from windows in the specified way.
    </p>

    <pre>
  &lt;and&gt;
    &lt;objects class="java.awt.Component"/&gt;
    &lt;not&gt;

      <b>&lt;reachable-objects&gt;</b>
        &lt;from&gt;
          &lt;objects class="java.awt.Window"/&gt;
        &lt;/from&gt;

        &lt;object-filter&gt;
          &lt;or&gt;
            &lt;objects class="java.awt.Component"/&gt;
            &lt;objects class="java.awt.Component[]"/&gt;
          &lt;/or&gt;
        &lt;/object-filter&gt;

        &lt;field-filter&gt;
          &lt;class name="java.awt.Container"&gt;
            &lt;allowed field="component"/&gt;
          &lt;/class&gt;
        &lt;/field-filter&gt;
      <b>&lt;/reachable-objects&gt;</b>

    &lt;/not&gt;
  &lt;/and&gt;
    </pre>

  </li>

  <li>
    <p>Tag <b>retained-objects</b> retrieves all objects that will be garbage collected if all the objects of the given set
    are garbage collected. The given set is included.
    In other words, retained set of set A is A itself and all
    the objects accessible from and only from A.
    These objects are called retained set, and its size called retained size.
    </p>

    <p>Example:</p>

    <p>The specification of all objects that will be garbage collected if all objects of class com.company.A and
    its subclasses are garbage collected: </p>

    <pre>
  &lt;retained-objects&gt;
    &lt;objects class="com.company.A"/&gt;
  &lt;/retained-objects&gt;
    </pre>
  </li>

  </ul>
<br/><br/></div><div><a name="ide_integration"></a>
<h2 class="faq">5&nbsp;&nbsp;IDE integration</h2>

  <p>
    IDE integration provides:
    <ul>
      <li>ability to <a href="#ide_integration_run">run profiling-enabled applications from IDE</a></li>
      <li><a href="#ide_integration_navigation">easy navigation</a> from profiler to application source code</li>
    </ul>
  </p>

  <p>
    To enable integration you should <a href="#ide_integration_plugins">install IDE plugin</a>.
  </p>

  <p>
    Supported IDEs:
    <ul>
      <li>Eclipse 3.0</li>
      <li>Eclipse 3.1</li>
      <li>IntelliJ IDEA 4.5</li>
      <li>JBuilder 7/8/9/X</li>
      <li>JDeveloper 10g</li>
    </ul>

    Known issues:
    <ul>
      <li>JBuilder and JDeveloper: there are problems with navigation to inner classes due to insufficient API.</li>
    </ul>
  </p>
<br/><br/></div><div><a name="ide_integration_plugins"></a>
<h2 class="faq">5.1&nbsp;&nbsp;Installation of plugins</h2>

  <p>
    To install IDE plugin, use <code class="action">Tools | Integrate with IDE...</code>
    (invoked automatically on first profiler run).
  </p>

  <p>
    If it is not possible to copy plugin automatically e.g. because superuser rights
    are required under Linux or Solaris, please follow instructions at
    <i>&lt;YJP Home&gt;</i>/lib/<i>&lt;your IDE&gt;</i>-plugin/readme.txt to complete plugin installation.
  </p>

  <p>
    Note: <a href="#ide_integration_navigation">Navigation</a> feature requires communication with IDE plugin via port.
    If port chosen by default is already in use (by another application), plugin fails to start.
    In that case please manually change 'plugin-port' parameter in file <nobr>&lt;user home&gt;/.yjp-3.2/ide-integration.config</nobr>.
  </p>
<br/><br/></div><div><a name="ide_integration_run"></a>
<h2 class="faq">5.2&nbsp;&nbsp;Run profiling-enabled applications from IDE</h2>

  After <a href="#ide_integration_plugins">installation of plugin</a>, new actions appear in your IDE:

  <ul>
    <li>
      <p>
        <b>Eclipse 3.0/3.1:</b><br/>
        <p>
          <code class="action">Run | Profile <i>XXX</i></code> actions in the main menu and "Profile" group in the main toolbar.
        </p>

        <a>
          Additional launch parameters can be configured in "Run | Profile...", tab "YourKit Java Profiler".
        </a>

        <p>
          Note: You might need to enable action group "Profile" under
          <code class="action">Window | Customize Perspective | Commands</code>
        </p>
      </p>
    </li>

    <li>
      <p>
        <b>IntelliJ IDEA 4.5:</b><br/>
        <p>
          <code class="action">Profile</code> action is accessible from the main toolbar,
          main menu and popup menus. It is located near IDEA's <code class="action">Run/Debug</code> actions.
        </p>

        <p>
          Additional launch parameters can be configured in "Run/Debug Configurations" dialog, tab "Startup/Connection"
        </p>
      </p>
    </li>

    <li>
      <p>
        <b>JBuilder 7/8/9/X:</b><br/>
        <p>
          <code class="action">Run | Optimize <i>XXX</i></code> actions in the main menu
          and "Optimize Project" group in the main toolbar.
        </p>
        <p>
          Note: You might need to select "YourKit Java Profiler" type in Optimize section
          of your runtime configuration.
        </p>
      </p>
    </li>

    <li>
      <p>
        <b>JDeveloper 10g:</b><br/>
        <p>
          <code class="action">Run | Profile <i>XXX</i></code> actions in the main menu
          and in the popup menus near JDeveloper's Run/Debug actions.
        </p>
      </p>
    </li>
  </ul>
<br/><br/></div><div><a name="ide_integration_navigation"></a>
<h2 class="faq">5.3&nbsp;&nbsp;Navigation action</h2>

  <p>
    Profiling applications, you usually need to browse related source code to understand
    performance problem.
    When problem is found and located, you edit source code to fix it.
  </p>

  <p>
    Instead of forcing you to tell profiler where source code of your application is located
    and showing the code in feature-restricted self-made editor surrogate, we provide an alternative approach.
    When you have a method, class or field selected in the profiler UI,
    just invoke <code class="action">Tools | Open Declaration in IDE Editor (F7)</code>
    to automatically open underlying source code in the editor of your IDE, the best place to browse and edit the code.
  </p>

  <p>
    The navigation action works on current selection and is available in both CPU and memory views.
    For example, if you have ClassFoo.methodBar() selected, F7 opens it in IDE's editor.
    Please note the extremely useful ability to locate code of anonymous classes and their methods, which is very hard to do manually.
  </p>
<br/><br/></div><div><a name="filters"></a>
<h2 class="faq">6&nbsp;&nbsp;Filters</h2>

  <p>
    <i>Filters</i> are intended to reduce the depth of call trees by means of skipping successive
    calls of methods from classes of standard libraries, application servers etc. and give more attention to
    methods of profiled application.
  </p>

  <p>
    Filters are applied to views where method call stacks are shown.
    With same snapshot you can use different filters or use no filters at all -
    you do not need to start a new profiling session for such a change.
    Views are automatically updated when filter settings are changed.
  </p>

  <p>
    Use <code class="action">Settings | Edit Filters...</code> to configure filters.
  </p>
<br/><br/></div><div><a name="options"></a>
<h2 class="faq">7&nbsp;&nbsp;User interface customization</h2>

  <p>
    Profiler interface can be customized via <code class="action">Settings | User Interface...</code>.
  </p>

  <ul>
    <li>
      <p>
      <i>"Reopen snapshots on startup"</i>. If this check box is checked the profiler automatically opens
      last open snapshots on next startup.
      </p>
    </li>

    <li>
      <p>
      <i>"Path to web browser"</i>. Specifies the command to start your favorite web browser from the profiler
      e.g. to show Help.
      Macro <i>$URL$</i> represents the URL of local file or web resource to be opened.
      </p>
      <p>
        This option is not available on Windows where the default system browser is always used.
      </p>
    </li>

    <li>
      <p>
      <i>"General and menu fonts"</i>. Customize font type and size. Under Windows, fonts are
      automatically retrieved from current desktop theme.
      </p>
    </li>

    <li>
      <p>
      <i>"Automatically position mouse cursor on default button"</i>. We provide this option to make work in
      profiler more convenient for those who use this feature in their native Windows applications.
      </p>
    </li>

    <li>
      <p>
      <i>"Tabbed Browsing"</i>. Working with profiler, you open new tabs,
      switch between tabs (Alt+Left, Alt+Right shortcuts) and close tabs that are not needed anymore
      (Ctrl+F4). You can use mouse to quickly close tabs.
      By default, middle button (wheel) click, click with pressed Shift or Ctrl close the tab.
      It is very useful that with mouse you can close non-selected tab, and selected tab will not be changed.
      </p>
      <p>
      You can customize how tabs will be located if many tabs are opened and they do not fit the horizontal space.
      It is possible to wrap tabs in multiple rows or scroll tabs within a single row.
      </p>
    </li>
  </ul>
<br/><br/></div><div><a name="api"></a>
<h2 class="faq">8&nbsp;&nbsp;Profiler API</h2>

  <p>
    API allows to control profiling programmatically.
    Also in your automatic memory tests you can open saved memory snapshots and examine them via <a href="#language">set description language</a>.
  </p>

  <p>Please find API JavaDoc at <a href="../api/index.html"><i>&lt;YJP Home&gt;</i>\docs\api\index.html</a></p>

  <p>
    To use the API, include <i>&lt;YJP Home&gt;</i>\lib\yjp.jar to the classpath.
    The API requires Java version 1.4.0 or higher.
  </p>

  <p>Samples of API usage please find at <a href="../../samples"><i>&lt;YJP Home&gt;</i>\samples</a>.</p>
</div></div>
        </td>
      </tr>

      <!-- footer -->

      <tr>
        <td>
          <table cellpadding="0" cellspacing="0" width="100%">
            <tr>
              <td id="footer_left">YourKit Java Profiler 3.2</td>
              <td id="footer">Copyright (c) 2003-2004 YourKit, LLC. All rights reserved.</td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>
</body>
</html>
