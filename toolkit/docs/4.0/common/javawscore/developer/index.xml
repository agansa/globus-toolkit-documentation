<?xml version='1.0' encoding='UTF-8'?>
<title> GT 4.0 Java WS Core : Developer&apos;s Guide</title>
<titleabbrev>Developer&apos;s Guide</titleabbrev>
<section id="s-javawscore-developer-introduction">
  <title>Introduction</title>
  <para>This guide contains information of interest to developers working with Java
  WS Core. It provides reference information for application developers, including
  APIs, architecture, procedures for using the APIs and code samples.</para>
</section>
<section id="s-javawscore-developer-beforeyoubegin">
  <title>Before you begin</title>
  <section id="s-javawscore-developer-features">
    <title>Feature summary</title>
    &Java_WS_Core_Feature_Summary_Frag;
  </section>
  <section id="s-javawscore-developer-platforms">
    <title>Tested platforms</title>
    &Java_WS_Core_Platform_Summary_Frag;
  </section>
  <section id="s-javawscore-developer-compatibility">
    <title>Backward compatibility summary</title>
    &Java_WS_Core_Compatibility_Summary_Frag;
  </section>
  <section id="s-javawscore-developer-dependencies">
    <title>Technology dependencies</title>
    &Java_WS_Core_Dependencies_Summary_Frag;
  </section>
  <section id="s-javawscore-developer-security_considerations">
    <title>Security Considerations </title>
    &Java_WS_Core_Security_Considerations_Frag;
  </section>
</section>
<section id="s-javawscore-developer-archdes">
  <title>Architecture and design overview</title>
  <itemizedlist>
    <listitem>
      <simpara>Java WS Core Design Document [<ulink url="developer/JavaWSCoreDesign.doc">doc</ulink> | <ulink url="developer/JavaWSCoreDesign.pdf">pdf</ulink>]</simpara>
    </listitem>
    <listitem>
      <simpara>Java WS Core UML [<ulink url="developer/JavaWSCoreUML.vsd">vsd</ulink> | <ulink url="developer/Resource.gif">Resource (.gif)</ulink>, <ulink url="developer/ResourceProperty.gif">Resource Property (gif)</ulink>, <ulink url="developer/Notification.gif">Notification (gif)</ulink>]</simpara>
    </listitem>
    <listitem>
      <simpara>Java WS Core Notification UML Sequence Diagrams [<ulink url="developer/NotificationSequences.vsd">vsd</ulink> | <ulink url="developer/NotificationSequence1.jpg">Subscription (jpg)</ulink>, <ulink url="developer/NotificationSequence2.jpg">Notification (jpg)</ulink>]</simpara>
    </listitem>
  </itemizedlist>
</section>
<section id="s-javawscore-developer-pubinterfaces">
  <title>Public interface</title>
  <para>The semantics and syntax of the APIs and WSDL for the component, along with
  descriptions of domain-specific structured interface data, can be found in
  the <xref linkend="c-javawscore-Public_Interfaces"/>.</para>
</section>
<section id="s-javawscore-developer-scenarios">
  <title>Usage scenarios</title>

  <section id="s-javawscore-developer-basics">
  <title>Basics</title>

  <section id="s-javawscore-developer-wsdlsoaprules">
  <title>WSDL/SOAP rules</title>

  <para>The <glossterm linkend="wsrf">WSRF</glossterm> and <glossterm linkend="wsn">WSN</glossterm> specifications schemas follow the <emphasis>document/literal</emphasis> mode as described in <glossterm linkend="wsibp">WS-I Basic Profile</glossterm>. The Basic Profile defines certain rules to follow for <emphasis>document/literal</emphasis> and
other modes to ensure interoperability. 
  </para>
  <para>Java WS Core relies on these restrictions so please keep them in mind when designing your own schema. 
</para>

  <section id="s-javawscore-developer-DocumentLiteral">
  <title>Document/literal</title>

<para>In the <emphasis>document/literal</emphasis> mode as defined in the <glossterm linkend="wsibp">WS-I Basic Profile</glossterm> at most one &lt;wsdl:part&gt; is allowed in the &lt;wsdl:message&gt; element and it must use the &apos;element&apos; attribute. Also, the wire signatures must be unique (cannot use the same &apos;element&apos; attribute in &lt;wsdl:part&gt; in two different &lt;wsdl:message&gt; elements). 
</para>

<note>
        <para><glossterm linkend="axis">Axis</glossterm>&apos; WSDL2Java tool might sometimes incorrectly detect
that schema follows the <emphasis>wrapped/literal</emphasis> mode and generate wrong stub and type classes. To ensure that <emphasis>document/literal</emphasis> mode is always used:
<itemizedlist>
            <listitem>
              <simpara>use Java WS Core&apos;s <computeroutput>generateStub*</computeroutput> Ant tasks in <computeroutput>&lt;install&gt;/share/globus_wsrf_tools/build-stubs.xml</computeroutput> file</simpara>
            </listitem>
            <listitem>
              <simpara>if you are using Axis&apos; WSDL2Java tool directly, you can alternatively specify the <computeroutput>-W</computeroutput> command line option.</simpara>
            </listitem>
          </itemizedlist>Also, with <emphasis>wrapped/literal</emphasis> mode, the element name had to match the operation
 name in wsdl. This is <emphasis>not</emphasis> necessary with <emphasis>document/literal</emphasis> mode.</para>
</note>
<para></para>
  </section>

  <section id="s-javawscore-developer-soapencoding">
  <title>SOAP Encoding</title>
<para>
Do <emphasis>not</emphasis> use or mix the literal mode with the SOAP encoding mode (<ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html#refinement16638080">R2706</ulink>). For example, do not use the <computeroutput>soapenc:Array</computeroutput> type. Please see the <ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html#refinement16556272">5.2.3 section</ulink> in the <glossterm linkend="wsibp">WS-I Basic Profile</glossterm> for details.
</para>

  </section>

  </section>

  <section id="s-javawscore-developer-OperationProvider">
    <title>Operation providers and its configuration</title>
    <para>GT3 introduced the concept of <emphasis>operation providers</emphasis> where a service could be composed
of different parts/classes. Java WS Core also supports this functionality. In
  GT3 operation providers had to implement a specific interface. In Java WS Core <emphasis>no</emphasis> such
  interface is required. In fact, an operation provider is not in
  any way different from a standard web service. That means that <emphasis>any</emphasis> web
service implementation can automatically be used as an operation provider (as
long as it uses common or standard interfaces to operate on resources).
</para>
    <para>To enable operation provider support for your service, make the following
  changes to the service deployment descriptor: <orderedlist>
        <listitem>
          <simpara>Change the value of the <computeroutput>provider</computeroutput> attribute to <computeroutput>Handler</computeroutput>.</simpara>
        </listitem>
        <listitem>
          <simpara>Add a <computeroutput>handleClass</computeroutput> parameter with a value of <classname>org.globus.axis.providers.RPCProvider</classname>.</simpara>
        </listitem>
        <listitem>
          <simpara>Specify providers in the <computeroutput>providers</computeroutput> parameter. </simpara>
          <para>The value
        of the parameter is a space-separated list of either provider names or
        class names. If provider names are used, they must  first be defined
        as  parameters in the <computeroutput>&lt;globalConfiguration&gt;</computeroutput> element
    of the <emphasis>main</emphasis> deployment descriptor (<computeroutput>etc\globus_wsrf_core\server-config.wsdd</computeroutput>). </para>
          <para>For example: </para>
          <screen>&lt;globalConfiguration&gt;
  ...
  &lt;parameter name=&quot;GetRPProvider&quot; 
              value=&quot;org.globus.wsrf.impl.properties.GetResourcePropertyProvider&quot;/&gt;
  ...
&lt;/globalConfiguration&gt;</screen>
        </listitem>
        <listitem>
          <simpara>Add or change the value of the <computeroutput>scope</computeroutput> parameter to <computeroutput>Application</computeroutput> or <computeroutput>Request</computeroutput>.</simpara>
        </listitem>
      </orderedlist></para>
    <para>The following is an example of a modified service deployment descriptor:
  
<screen>&lt;service name=&quot;SubscriptionManagerService&quot; <emphasis> provider=&quot;Handler&quot;</emphasis> use=&quot;literal&quot; style=&quot;document&quot;&gt;
  &lt;parameter name=&quot;allowedMethods&quot; value=&quot;*&quot;/&gt;
  <emphasis>&lt;parameter name=&quot;scope&quot; value=&quot;Application&quot;/&gt;</emphasis>
  <emphasis>&lt;parameter name=&quot;providers&quot; value=&quot;
                     GetRPProvider 
                     org.globus.wsrf.impl.lifetime.SetTerminationTimeProvider
                     PauseSubscriptionProvider&quot;/&gt;</emphasis>
  <emphasis>&lt;parameter name=&quot;handlerClass&quot; value=&quot;org.globus.axis.providers.RPCProvider&quot;/&gt;</emphasis>
  &lt;parameter name=&quot;className&quot; 
            value=&quot;org.globus.wsrf.impl.notification.ResumeSubscriptionProvider&quot;/&gt;
  &lt;wsdlFile&gt;share/schema/core/notification/subscription_manager_service.wsdl&lt;/wsdlFile&gt;
&lt;/service&gt;</screen>

<note>
        <simpara>The operations defined in the <computeroutput>className</computeroutput> service always overwrite the providers&apos; operations. That is, if one provider defines the same method as the service specified in the <computeroutput>className</computeroutput> parameter, the operation will be invoked on the service. Also, if two providers define the same method, the first one specified in the <computeroutput>providers</computeroutput> parameter will be invoked.</simpara>
      </note></para>
  </section>

  <section id="s-javawscore-developer-JNDIDetails">
    <title>JNDI configuration file</title>
    <para>Java WS Core provides <ulink url="http://jakarta.apache.org/tomcat/tomcat-5.0-doc/jndi-resources-howto.html">Tomcat&apos;s JNDI</ulink> implementation. The file format of Java WS Core&apos;s <computeroutput>jndi-config.xml</computeroutput> is slightly different from the Tomcat&apos;s <computeroutput>server.xml</computeroutput> file. One main difference is that the <computeroutput>&lt;resourceParams&gt;</computeroutput> are specified as children of <computeroutput>&lt;resource&gt;</computeroutput> objects. Also, Java WS Core&apos;s <computeroutput>jndi-config.xml</computeroutput> parser is case sensitive and all element names are lowercase. 
</para>
    <para>All elements defined in the <computeroutput>&lt;global&gt;</computeroutput> section of the JNDI configuration file are deployed into the <computeroutput>java:comp/env</computeroutput> context under the name specified in the &apos;name&apos; attribute. All <computeroutput>&lt;service&gt;</computeroutput> elements are deployed into the <computeroutput>java:comp/env/services/&lt;service name&gt;</computeroutput> context. New objects and contexts can be added or modified dynamically at runtime but they will not be persisted. The only way to always have an object around is to deploy it in the <computeroutput>jndi-config.xml</computeroutput> file. All services <emphasis>share</emphasis> the same <computeroutput>java:comp/env</computeroutput> context. This is different from EJBs where each EJB has a separate <computeroutput>java:comp/env</computeroutput> context. 
</para>
    <para>When deploying <computeroutput>&lt;resource&gt;</computeroutput> in <computeroutput>jndi-config.xml</computeroutput>,
make sure to use the <computeroutput>org.globus.wsrf.tools.jndi.BeanFactory</computeroutput> as a
BeanFactory (value of a &apos;factory&apos; parameter) instead of <computeroutput>org.apache.naming.factory.BeanFactory</computeroutput>.
Your bean must have a default constructor. If your bean implements the <computeroutput>org.globus.wsrf.jndi.Initializable</computeroutput> interface,
the <computeroutput>initialize()</computeroutput> function will be automatically called after all
parameters are set on the bean. 
</para>
    <para>Please see <ulink url="http://java.sun.com/products/jndi/tutorial/">The JNDI Tutorial</ulink> for more information on JNDI programming. 
</para>
  </section>


  <section id="Activation">
    <title>Lifecycle and activation</title>
    <section>
      <title>Activating a service</title>
      <para>To activate a service, an RPCProvider is available from both Axis and Globus. </para>
    </section>
    <section>
      <title>Activating a service using the Axis RPCProvider</title>
      <para>
The <computeroutput>scope</computeroutput> setting of the service dictates when and how service instances
are created:</para>
      <table>
        <title>Scope settings</title>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>
                <emphasis>Application</emphasis>
              </entry>
              <entry>One instance of the service is used for all invocations.</entry>
            </row>
            <row>
              <entry>
                <emphasis>Request</emphasis>
              </entry>
              <entry>One instance is created per invocation. This is the default (if scope parameter is not set in the deployment descriptor).</entry>
            </row>
            <row>
              <entry>
                <emphasis>Session</emphasis>
              </entry>
              <entry> One instance is created per session. </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>If the service
        implements the <ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/rpc/server/ServiceLifecycle.html">javax.xml.rpc.server.ServiceLifecycle</ulink> interface,
        the lifecycle methods  will be called according to the <computeroutput>scope</computeroutput> setting
  as a service instance is created and destroyed. </para>
      <para>For example, in <emphasis>Application</emphasis> scope, <emphasis>destroy()</emphasis> will
          be called on container shutdown, and in <emphasis>Request</emphasis> scope it will
be called after the service method is called. </para>
      <para>  With Axis RPCProvider, JAAS credentials are never associated with the
invocation thread. </para>
    </section>
    <section>
      <title>Activating a service using the Globus RPCProvider</title>
      <para>
The <computeroutput>scope</computeroutput> setting of the service dictates when and how service instances
are created (only <emphasis>Application</emphasis> and <emphasis>Request</emphasis> scopes are supported
with Globus RPCProvider):</para>
      <table>
        <title>Scope settings and activation</title>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>
                <emphasis>Application</emphasis>
              </entry>
              <entry>
                <para>Service/provider instances are created either on first invocation
        or on container startup. The behavior is determined by the value 
        of the 
        &quot;loadOnStartup&quot; 
        parameter. This will work in the same way in both the stand-alone 
        container and in Tomcat. </para>
                <para>        If the service or the container is configured with a security
        descriptor, the appropriate credentials will be associated with the thread
        during activation (using JAAS). Also, during activation a basic Axis
        MessageContext will be associated with the thread with only <computeroutput>Constants.MC_HOME_DIR</computeroutput>, <computeroutput>Constants.MC_CONFIGPATH</computeroutput>,
    and the right target service properties set (see <xref linkend="s-javawscore-developer-ContextProperties"/> for details). If service or providers implement the <ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/rpc/server/ServiceLifecycle.html">javax.xml.rpc.server.ServiceLifecycle</ulink> interface,
    the lifecycle methods will be called accordingly. </para>
              </entry>
            </row>
            <row>
              <entry>
                <emphasis>Request</emphasis>
              </entry>
              <entry>
                <para>One instance is created per invocation. This is the default (if scope
      parameter is not set in the deployment descriptor).</para>
                <para>Behaves more or less just like the Axis RPCProvider (service/providers
        instances are created per invocation, ServiceLifecycle methods called
        right before and after service method invocation, no JAAS credentials
      during ServiceLifecycle methods). </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section>
      <title>Activating a ResourceHome</title>
      <para>A <glossterm linkend="ResourceHome">ResourceHome</glossterm> will be activated either on the first service invocation or, 
if <emphasis>&quot;loadOnStartup&quot;</emphasis> parameter  is set to <emphasis>&quot;true&quot;</emphasis>, during container 
startup. Both mechanisms trigger actual activation by looking up the ResourceHome 
in the JNDI directory. This initial lookup causes a proper MessageContext 
and/or JAAS subject to be associated with the current thread, instantiation of 
the object implementing the ResourceHome and, if the ResourceHome implements the 
<emphasis>org.globus.wsrf.jndi.Initializable</emphasis> interface, the invocation of the 
<emphasis>initialize()</emphasis> function.
</para>
      <para>In fact, the same steps are performed upon initial lookup of any JNDI <emphasis>resource</emphasis> entry that 
uses the <emphasis>org.globus.wsrf.jndi.BeanFactory</emphasis> class for its factory and is defined directly 
under a <emphasis>service</emphasis> entry in a <emphasis>jndi-config.xml</emphasis> file.
</para>
    </section>
    <section>
      <title>Activating ServiceResourceHome</title>
      <para>If you are using a ServiceResourceHome please make sure to deploy the service with the <emphasis>&quot;loadOnStartup&quot;</emphasis> option enabled and in <emphasis>Application</emphasis> scope. That will ensure that the ResourceHome is initialized with the right service/resource.
</para>
    </section>
  </section>

  </section>

  <section id="s-javawscore-developer-programming">
    <title>Programming</title>

  <section id="s-javawscore-developer-programming-general">
    <title>General</title>

  <section id="s-javawscore-developer-ApacheAddressing">
    <title>Using Apache Addressing API</title>
    <para>The WS-RF and WS-N specifications distributed with Java WS Core use <emphasis>WS-Addressing</emphasis> (the
March 2004 version of the specification) for addressing services and resources.
Java WS Core uses the <ulink url="http://ws.apache.org/ws-fx/addressing/">Apache Addressing</ulink> library for WS-Addressing support. The API is pretty straightforward
and easy to use. Most of the work is done in <computeroutput>AddressingHandler</computeroutput> deployed
in the client and server configuration files. See <ulink url="http://ws.apache.org/ws-fx/addressing/">Apache Addressing documentation</ulink> for details.
</para>
  <section id="s-javawscore-developer-call">
    <title>Call object</title>
    <para>If you are using the <computeroutput>javax.xml.rpc.Call</computeroutput> object directly, you can pass the addressing information by setting a <computeroutput>Constants.ENV_ADDRESSING_REQUEST_HEADERS</computeroutput> property on the call object. </para>
    <para>For example:
<screen>Service service = new Service();
Call call = (Call) service.createCall();

String url = &quot;http://localhost:8080/axis/services/Version&quot;;

AddressingHeaders headers = new AddressingHeaders();
headers.setTo(new To(url));

// pass the addressing info to the addressing handler
call.setProperty(Constants.ENV_ADDRESSING_REQUEST_HEADERS, headers);

call.setTargetEndpointAddress(new URL(url));
call.setOperationName(new QName(url, &quot;getVersion&quot;)); // url here is just a namespace

String ret = (String) call.invoke(new Object[]);</screen>
</para>
  </section>
  <section id="s-javawscore-developer-addressinglocator">
    <title>AddressingLocator class</title>
    <para>The Apache Addressing library also contains a version of Axis&apos; WSDL2Java tool.
  It extends the Axis&apos; WSDL2Java tool functionality by generating, in addition
  to all the regular classes, the <interfacename>&lt;service&gt;Addressing</interfacename> interface
and <interfacename>&lt;service&gt;AddressingLocator</interfacename> class. </para>
    <para>The <computeroutput>AddressingLocator</computeroutput>  class can be used to get a stub for a service by passing the Apache Addressing <computeroutput>EndpointReferenceType</computeroutput> parameter. </para>
    <para>For example: 
<screen>String url = &quot;http://localhost:8080/axis/services/Version&quot;;

EndpointReferenceType epr = new EndpointReferenceType();
epr.setAddress(new Address(url));

VersionServiceAddressingLocator locator =
     new VersionServiceAddressingLocator();

VerionServicePortType port = locator.getVersionPort(epr);

port.getVersion();</screen>
</para>
  </section>
  <section id="s-javawscore-developer-referenceproperties">
    <title>ReferenceProperties</title>
    <para>In the WS-RF  and WS-N specifications, the WS-Addressing <computeroutput>ReferenceProperties</computeroutput> are used to carry resource identity information. The resource identity can be anything as long as it serializes as a XML element. The <computeroutput>ReferenceProperties</computeroutput> are serialized as separate SOAP headers in the SOAP envelope.
</para>
    <para>The Apache Addressing library only allows a DOM <computeroutput>Element</computeroutput> or a <computeroutput>SOAPElement</computeroutput> to
  be a reference property. </para>
    <para>For example, create <computeroutput>ReferencePropertiesType</computeroutput> and fill it with resource key info: </para>
<screen>// create a reference property
QName keyName = new QName(&quot;http://axis.org&quot;, &quot;VersionKey&quot;);
String keyValue = &quot;123&quot;;
 
SimpleResourceKey key = new SimpleResourceKey(keyName, keyValue);

ReferencePropertiesType props = new ReferencePropertiesType();

// convert to SOAPElement and add to the list
props.add(key.toSOAPElement()); 
...</screen>
<para>Then pass it to <computeroutput>AddressingHeaders</computeroutput>:</para>
<screen>...
Service service = new Service();
Call call = (Call) service.createCall();

String url = &quot;http://localhost:8080/axis/services/Version&quot;;

AddressingHeaders headers = new AddressingHeaders();
headers.setTo(new To(url));
<emphasis>headers.setReferenceProperties(props);</emphasis>

// pass the addressing info to the addressing handler
call.setProperty(Constants.ENV_ADDRESSING_REQUEST_HEADERS, headers);

call.setTargetEndpointAddress(new URL(url));
call.setOperationName(new QName(url, &quot;getVersion&quot;)); // url here is just a namespace

String ret = (String) call.invoke(new Object[]);</screen>
<para>
Or set it on <computeroutput>EndpointReferenceType</computeroutput>:
</para>
<screen>...
String url = &quot;http://localhost:8080/axis/services/Version&quot;;

EndpointReferenceType epr = new EndpointReferenceType();
epr.setAddress(new Address(url));
<emphasis>epr.setProperties(props);</emphasis>

VersionServiceAddressingLocator locator =
    new VersionServiceAddressingLocator();

VerionServicePortType port = locator.getVersionPort(epr);

port.getVersion();</screen>
<para></para>
  </section>
  </section>

  <section id="s-javawscore-developer-NotificationConsumer">
    <title>Setting up and receiving notifications (Notification Consumer)</title>
    <para>There are a few steps involved in setting up and receiving notifications:</para>

    <section id="s-javawscore-developer-callback">
      <title>Step 1: Implement the callback </title>
      <para>The notification consumer application must provide an implementation of the <computeroutput>org.globus.wsrf.NotifyCallback</computeroutput> interface. The <computeroutput>deliver</computeroutput> function of the interface will be invoked whenever a notification for that consumer arrives. The <computeroutput>message</computeroutput> parameter will either be of <computeroutput>org.w3c.dom.Element</computeroutput> type if the message type was unknown or some object mapped to the type of the message. </para>
      <para><note>
          <simpara>The <computeroutput>deliver</computeroutput> function should be thread-safe as multiple notifications might come at once. Notifications might also come unordered and some might even be lost (due to network failures).</simpara>
        </note></para>
    </section>
    <section id="s-javawscore-developer-notificationconsumermgr">
      <title>Step 2: Start NotificationConsumerManager</title>
      <para>In order to facilitate the receipt of notifications, start a <computeroutput>NotificationConsumerManager</computeroutput> by
doing the following: </para>
<screen>import org.globus.wsrf.NotificationConsumerManager; 
...

NotificationConsumerManager consumer = null;
try {
   consumer = NotificationConsumerManager.getInstance();
   consumer.startListening();
   ...
} catch (...) {
   ...
}</screen>


 <important>
    <simpara>
     On the client when the 
     <computeroutput>consumer.startListening()</computeroutput> is called
     an embedded container is actually started in the background. That embedded
     container is the same as the standalone container but configured with
     only one or two services needed to handle the notifications. 
     Therefore, any client using notification consumer API will have the 
     same dependencies on the libraries and configurations files as the basic
     standalone container code. 
     Also, please check the <xref linkend="s-javawscore-user-notificationconsumer"/> if the <computeroutput>consumer.startListening()</computeroutput> call
     failed on the client.
   </simpara>

   <simpara>
     On the server when the 
     <computeroutput>consumer.startListening()</computeroutput> is called
     the container in which the service is running in is used to receive
     the notifications. Therefore, there are no extra dependencies.
   </simpara>
 </important>
    </section>
    <section id="s-javawscore-developer-registrationcallback">
      <title>Step 3: Register the callback</title>
      <para>Register the callback implementation with the <computeroutput>NotificationConsumerManager</computeroutput> (once
it is started) using the <computeroutput>createNotificationConsumer</computeroutput> function. </para>
      <para>The <computeroutput>createNotificationConsumer</computeroutput> function
  returns an endpoint for this notification consumer. </para>
      <para>Example:
<screen>import org.globus.wsrf.NotifyCallback;
import org.apache.axis.message.addressing.EndpointReferenceType;
...

   MyCallback callback = new MyCallback();
   EndpointReferenceType consumerEPR =
       consumer.createNotificationConsumer(callback);
   ...

class MyCallback implements NotifyCallback {
  ....
}</screen>
</para>
    </section>
    <section id="subscription">
      <title>Step 4: Subscribe to the callback</title>
      <para>Pass the endpoint returned by the <computeroutput>createNotificationConsumer</computeroutput> function
to the subscribe call. </para>
      <para>Example: 
<screen>import org.oasis.wsn.TopicExpressionType;
import org.oasis.wsn.Subscribe;
import org.oasis.wsn.SubscribeResponse;
import org.globus.wsrf.WSNConstants;
import org.globus.wsrf.WSRFConstants;
...

TopicExpressionType topicExpression = new TopicExpressionType();
topicExpression.setDialect(WSNConstants.SIMPLE_TOPIC_DIALECT);
topicExpression.setValue(WSRFConstants.TERMINATION_TIME);

Subscribe request = new Subscribe();
request.setUseNotify(Boolean.TRUE);
request.setConsumerReference(consumerEPR);
request.setTopicExpression(topicExpression);

SubscribeResponse subResponse = port.subscribe(request);
...</screen>
</para>
    </section>
    <section id="s-javawscore-developer-cleanup">
      <title>Step 5: Clean up</title>
      <para>Once done with the notifications, do the following clean up tasks.</para>
      <formalpara>
        <title>Step 5a: Destroy subscriptions resource</title>
        <para>Make sure to
    explicitly destroy the subscription resource or set its termination time. Example: 
<screen>import org.globus.wsrf.core.notification.SubscriptionManager;
import org.globus.wsrf.core.notification.service.SubscriptionManagerServiceAddressingLocator;
import org.oasis.wsrf.lifetime.Destroy;
...

SubscriptionManagerServiceAddressingLocator sLocator = new SubscriptionManagerServiceAddressingLocator();
SubscriptionManager manager = sLocator.getSubscriptionManagerPort(
                        subResponse.getSubscriptionReference());
manager.destroy(new Destroy());
...</screen>
</para>
      </formalpara>
      <formalpara>
        <title>Step 5b: Un-register the callback</title>
        <para>
Make sure to  call (especially in error cases) the <emphasis>
            <computeroutput>NotificationConsumerManager.removeNotificationConsumer()</computeroutput>
          </emphasis> function
  to unregister the callback from the <computeroutput>NotificationConsumerManager</computeroutput>.
</para>
      </formalpara>
      <formalpara>
        <title>Step 5c: Release resources</title>
        <para>In addition, make sure to always call the <emphasis>
            <computeroutput>NotificationConsumerManager.stopListening()</computeroutput>
          </emphasis> function
  when finished using the <computeroutput>NotificationConsumerManager</computeroutput>. Otherwise,
  some resources might not be released. 
Example: 
<screen>   ...
} catch(Exception e) {
   ...
} finally {
   if (consumer != null) {
      try { consumer.stopListening(); } catch (Exception ee) {}
   }
}</screen>
</para>
      </formalpara>
    </section>
  </section>

  </section>

    <section id="s-javawscore-developer-programming-server">
    <title>Service-side specific</title>

  <section id="s-javawscore-developer-EndpointInfo">
    <title>Obtaining container endpoint information</title>
    <para>In most cases, a service will need to return the endpoint information of the container to a client. Unfortunately, getting that information might not be easy. The only reliable way of getting the container endpoint information is to extract it from the <computeroutput>MessageContext.TRANS_URL</computeroutput> property of the <computeroutput>MessageContext/ResourceContext</computeroutput> associated with the current thread. We provide <computeroutput>ServiceHost</computeroutput> API to obtain that information easily. For example:
</para>
<screen>import org.globus.wsrf.container.ServiceHost;
...
URL containerBaseUrl = ServiceHost.getBaseURL();
...</screen>
<para>The above will return the base container URL such as <computeroutput>http://localhost:8080/wsrf/services/</computeroutput>.
</para>
    <para>We also provide a convenient API for creating WS-Addressing endpoints. For example:
</para>
<screen>import org.apache.axis.message.addressing.EndpointReferenceType;
import org.globus.wsrf.utils.AddressingUtils;
...
EndpointReferenceType containerEndpoint = 
       AddressingUtils.createEndpointReference(null);
...</screen>
<para>The above will return the <computeroutput>EndpointReferenceType</computeroutput> object with the <computeroutput>Address</computeroutput> field set to the base container URL (as before) and empty reference properties.
</para>
    <para>
<note>
        <simpara>The <computeroutput>ServiceHost</computeroutput> API will return the correct information and <computeroutput>AddressingUtils</computeroutput> API will work correctly only if called from the same thread as the service method was invoked from.</simpara>
      </note> </para>
  </section>

    <section>
      <title>Obtaining service parameters</title>
      <para>While we  strongly recommend that you use the JNDI mechanism to provide your service with configuration information, it is sometimes necessary to obtain the value of parameters set in the <glossterm linkend="wsdd">WSDD</glossterm> file. Java WS Core provides some helper functions to ease this process:<screen>import org.globus.wsrf.utils.ContextUtils;
import org.apache.axis.MessageContext;
...
MessageContext context = MessageContext.getCurrentContext();
String sampleProperty = (String)
    ContextUtils.getServiceProperty(context, &quot;myProperty&quot;);
...</screen></para>
      <para>Note that this function requires that a <classname>MessageContext</classname> is associated with the current thread,  which in general means that the call needs to happen within the context of a web service invocation.</para>
      <note>
        <simpara>Specifying parameters using WSDD files depends on Axis and will likely not be supported in future versions of the toolkit.</simpara>
      </note>
    </section>

 <section id="s-javawscore-developer-ContextProperties">
    <title>Obtaining standard MessageContext properties</title>
    <para>The following properties can be obtained from the SOAPContext/MessageContext associated with the current thread:

<itemizedlist>
        <listitem>
          <simpara><emphasis>
              <computeroutput>org.apache.axis.Constants.MC_HOME_DIR</computeroutput>
            </emphasis> - the base directory from which the wsdl files are loaded.</simpara>
        </listitem>
        <listitem>
          <simpara><emphasis>
              <computeroutput>org.apache.axis.Constants.MC_CONFIGPATH</computeroutput>
            </emphasis> - the base directory from which different configuration files are loaded.</simpara>
        </listitem>
        <listitem>
          <simpara><emphasis>
              <computeroutput>org.apache.axis.Constants.MC_REMOTE_ADDR</computeroutput>
            </emphasis> - the IP address of the client.</simpara>
        </listitem>
        <listitem>
          <simpara><emphasis>
              <computeroutput>org.apache.axis.MessageContext.TRANS_URL</computeroutput>
            </emphasis> - the URL of the request.</simpara>
        </listitem>
      </itemizedlist></para>
    <para>The <computeroutput>Constants.MC_CONFIGPATH</computeroutput> property should be used to load any type of configuration file. Only <computeroutput>Constants.MC_CONFIGPATH</computeroutput> and <computeroutput>Constants.MC_HOME_DIR</computeroutput> are associated with the thread during activation.

In the standalone container the <computeroutput>Constants.MC_HOME_DIR</computeroutput> and <computeroutput>Constants.MC_CONFIGPATH</computeroutput> properties will usually point to the same directory. However, in Tomcat they will point to two different directories. Since GT 4.0.1, the <computeroutput>Constants.MC_HOME_DIR</computeroutput> value can be accessed using the <computeroutput>org.globus.wsrf.ContainerConfig.getSchemaDirectory()</computeroutput> static call, and <computeroutput>Constants.MC_CONFIGPATH</computeroutput> value via the <computeroutput>org.globus.wsrf.ContainerConfig.getBaseDirectory()</computeroutput> static call.
</para>
  </section>

  <section id="s-javawscore-developer-LocalInvocations">
    <title>Making local calls</title>
    <para>Services in the container can be invoked locally. Local invocations work just like remote invocations (all handlers are called, messages get serialized/deserialized) but messages do not travel over the network - everything happens in memory. 
</para>
    <para>Local invocations can only be made on the server side and only when a Axis MessageContext is associated with a current thread. URLs with &quot;<emphasis>local</emphasis>&quot; protocol name are used for local invocations. </para>
    <para>To invoke a service locally, do the following: </para>
    <para><orderedlist>
        <listitem>
          <para>Register &quot;<emphasis>local</emphasis>&quot; protocol handler:
<screen>import org.globus.axis.transport.local.LocalTransportUtils;
...
<emphasis>LocalTransportUtils.init();</emphasis>
...</screen></para>
        </listitem>
        <listitem>
          <para>Create a service URL with &quot;<emphasis>local</emphasis>&quot; protocol:
<screen>URL url = new URL(<emphasis>&quot;local:///wsrf/services/MyService&quot;</emphasis>);</screen></para>
        </listitem>
        <listitem>
          <para>Configure the service stub for local invocation and make the call:
<screen>MyServiceAddressingLocator locator = 
       new MyServiceAddressingLocator();
MyService port = locator.getMyServicePort(url);

<emphasis>LocalTransportUtils.enableLocalTransport((Stub)port);</emphasis>

port.hello();</screen></para>
        </listitem>
      </orderedlist></para>
  </section>

    </section>

    <section id="s-javawscore-developer-programming-client">
    <title>Client-side specific</title>

    <section id="s-javawscore-developer-WritingClients">
    <title>Client notes</title>
    <para>Any program that is based on Java WS Core should contain as a first entry in its classpath the directory of the Java WS Core installation. This is to ensure that the right <glossterm linkend="client-config.wsdd">client-config.wsdd</glossterm> is used by the client. That configuration file contains important client-side information such as handlers, type mappings, etc.
</para>
    <para>Also, any program that is a notification consumer should be initialized with
  the appropriate <computeroutput>GLOBUS_LOCATION</computeroutput> system property (set to the installation
  directory of Java WS Core). If the system property is not set, the notification
  consumer might not initialize or work properly.
</para>
  </section>

    </section>

  </section>


  <section id="s-javawscore-developer-deploying">
  <title>Deploying</title>

  <section id="s-javawscore-developer-gardetails">
    <title>Grid Archive (GAR) </title>
    <para>The GAR (Grid Archive) file is a single file which contains all the files and information that the container needs to deploy a service. The GAR files are deployed using globus-deploy-gar (<xref linkend="deployGar"/>) and undeployed using globus-undeploy-gar (<xref linkend="undeployGar"/>) tools.
</para>
  <section>
      <title>GAR file structure</title>
      <table>
        <title>GAR file structure</title>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>
                <computeroutput>docs/</computeroutput>
              </entry>
              <entry>This directory contains service documentation files. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>share/</computeroutput>
              </entry>
              <entry>This directory contains files that can be accessed or used by all services. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>schema/</computeroutput>
              </entry>
              <entry>This directory contains service WSDL and schema files. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>etc/</computeroutput>
              </entry>
              <entry>This directory contains service configuration files and a <computeroutput>post-deploy.xml</computeroutput> Ant script.</entry>
            </row>
            <row>
              <entry>
                <computeroutput>bin/</computeroutput>
              </entry>
              <entry>This directory contains service executables such as command line tools, GUI, etc. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>lib/</computeroutput>
              </entry>
              <entry>This directory contains service and third party library files and any LICENSE files. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>server-deploy.wsdd</computeroutput>
              </entry>
              <entry>This file is the server side deployment descriptor. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>client-deploy.wsdd</computeroutput>
              </entry>
              <entry>This file is the client side deployment descriptor. </entry>
            </row>
            <row>
              <entry>
                <computeroutput>jndi-config-deploy.xml</computeroutput>
              </entry>
              <entry>This file is the JNDI configuration file. </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="s-javawscore-developer-gardeploy">
      <title>Deployment process</title>
      <para>The contents of the GAR file are processed in the following way (all steps
  are performed only if necessary):</para>
      <itemizedlist>
        <listitem>
          <simpara>Any files in the <computeroutput>docs/</computeroutput> directory in the GAR are copied into the <computeroutput>$GLOBUS_LOCATION/docs/&lt;gar.id&gt;/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>Any files in the <computeroutput>share/</computeroutput> directory in the GAR are copied into the <computeroutput>$GLOBUS_LOCATION/share/&lt;gar.id&gt;/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>Any files in the <computeroutput>schema/</computeroutput> directory in the GAR are copied into the <computeroutput>$GLOBUS_LOCATION/share/schema/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>Any files in the <computeroutput>etc/</computeroutput> directory in the GAR are copied into the <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>Any files in the <computeroutput>bin/</computeroutput> directory in the GAR are copied into the <computeroutput>$GLOBUS_LOCATION/bin/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>Any <computeroutput>.jar</computeroutput> files in the <computeroutput>lib/</computeroutput> directory of the GAR are copied into the <computeroutput>$GLOBUS_LOCATION/lib/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>Any file that contains the word &quot;LICENSE&quot; in the name in the <computeroutput>lib/</computeroutput> directory of the GAR is copied into the <computeroutput>$GLOBUS_LOCATION/share/licenses/</computeroutput> directory.</simpara>
        </listitem>
        <listitem>
          <simpara>The <computeroutput>server-deploy.wsdd</computeroutput> in the GAR is copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/server-config.wsdd</computeroutput>. If a profile name was specified during deployment, the <computeroutput>server-deploy.wsdd</computeroutput> will be copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-server-config.wsdd</computeroutput>. The <computeroutput>server-config.wsdd</computeroutput> file will be set with user-only access permissions.</simpara>
        </listitem>
        <listitem>
          <simpara>The <computeroutput>jndi-config-deploy.xml</computeroutput> in the GAR is copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/jndi-config.xml</computeroutput>. If a profile name was specified during deployment the <computeroutput>jndi-config-deploy.xml</computeroutput> will be copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-jndi-config.xml</computeroutput>. The <computeroutput>jndi-config.xml</computeroutput> file will be set with user only-access permissions.</simpara>
        </listitem>
        <listitem>
          <simpara>The <computeroutput>client-deploy.wsdd</computeroutput> in the GAR is merged into a common <computeroutput>$GLOBUS_LOCATION/client-config.wsdd</computeroutput> file.</simpara>
        </listitem>
        <listitem>
          <simpara>An undeploy script (<computeroutput>$GLOBUS_LOCATION/etc/globus_packages/&lt;gar.id&gt;/undeploy.xml</computeroutput>) is created.</simpara>
        </listitem>
        <listitem>
          <simpara>A <computeroutput>etc/post-deploy.xml</computeroutput> Ant script is called if the GAR contains one. The <emphasis>setup</emphasis> target is called automatically.</simpara>
        </listitem>
      </itemizedlist>
      <para>Notes:</para>
      <itemizedlist>
        <listitem>
          <simpara>If the <computeroutput>post-deploy.xml</computeroutput> script creates some files, they will <emphasis>not</emphasis> be removed by <computeroutput>undeploy</computeroutput>.</simpara>
        </listitem>
        <listitem>
          <simpara>During deployment, filtering is done for contents of the <computeroutput>server-deploy.wsdd</computeroutput> and <computeroutput>jndi-config-deploy.xml</computeroutput> files to replace the <computeroutput>@config.dir@</computeroutput> token with the &quot;<computeroutput>etc/&lt;gar.id&gt;</computeroutput>&quot; value, and the <computeroutput>@gar.id@</computeroutput> token with the &quot;<computeroutput>&lt;gar.id&gt;</computeroutput>&quot; value.</simpara>
        </listitem>
      </itemizedlist>
    <para></para>
    </section>
    <section>
      <title>Creating a GAR file through Ant</title>
      <section>
        <title>Creating GAR file</title>
        <para>
To create a GAR file use the following example:
</para>
        <screen>&lt;property name=&quot;build.packages&quot; location=
      &quot;${deploy.dir}/share/globus_wsrf_common/build-packages.xml&quot;/&gt;
...
&lt;property name=&quot;garjars.id&quot; value=&quot;garjars&quot;/&gt;
&lt;fileset dir=&quot;lib&quot; id=&quot;garjars&quot;/&gt;

&lt;property name=&quot;garetc.id&quot; value=&quot;garetc&quot;/&gt;
&lt;fileset dir=&quot;etc&quot; id=&quot;garetc&quot;/&gt;
...
&lt;target name=&quot;dist&quot; depends=&quot;...&quot;&gt;
  &lt;ant antfile=&quot;${build.packages}&quot; target=&quot;makeGar&quot;&gt;
    &lt;property name=&quot;gar.name&quot; value=&quot;mygar.gar&quot;/&gt;
    &lt;reference refid=&quot;${garjars.id}&quot;/&gt;
    &lt;reference refid=&quot;${garetc.id}&quot;/&gt;
  &lt;/ant&gt;            
&lt;/target&gt;</screen>
        <para>The <computeroutput>gar.name</computeroutput> property must be passed. That property specifies the gar file to create. The <computeroutput>makeGar</computeroutput> task will look for <computeroutput>deploy-client.wsdd</computeroutput>, <computeroutput>deploy-server.wsdd</computeroutput>, and <computeroutput>deploy-jndi-config.xml</computeroutput> files in the base directory of the calling Ant process. All of these files are optional and do not have exist. The list of files to be included in the GAR file is passed via Ant references. The <computeroutput>makeGar</computeroutput> accepts the following references: <computeroutput>garjars.id</computeroutput>, <computeroutput>garschema.id</computeroutput>, <computeroutput>garetc.id</computeroutput>, <computeroutput>garshare.id</computeroutput>, <computeroutput>gardocs.id</computeroutput>, and <computeroutput>garbin.id</computeroutput>. All of these references are optional and do not have to be defined.</para>
        <para>In the above example, all files in the <computeroutput>etc</computeroutput> and <computeroutput>lib</computeroutput> directories, and the <computeroutput>deploy-client.wsdd</computeroutput>, <computeroutput>deploy-server.wsdd</computeroutput>, and <computeroutput>deploy-jndi-config.xml</computeroutput> files (if they exist) will be included into the GAR file.
</para>
      </section>
      <section>
        <title>Deploying GAR file</title>
        <para>
To deploy a GAR file use the following example:
</para>
        <screen>&lt;property name=&quot;build.packages&quot; location=
      &quot;${deploy.dir}/share/globus_wsrf_common/build-packages.xml&quot;/&gt;
...
&lt;target name=&quot;deploy&quot; depends=&quot;...&quot;&gt;
  &lt;ant antfile=&quot;${build.packages}&quot; target=&quot;deployGar&quot;&gt;
    &lt;property name=&quot;gar.name&quot; value=&quot;mygar.gar&quot;/&gt;
  &lt;/ant&gt;
&lt;/target&gt;</screen>
        <para>The <computeroutput>gar.name</computeroutput> property must be passed. That property specifies the gar file to deploy. Optionally, the <computeroutput>profile</computeroutput> property can be passed to indicate which configuration profile the gar should be deployed under.
</para>
      </section>
      <section>
        <title>Undeploying GAR file</title>
        <para>To undeploy a GAR file use the following example:
</para>
        <screen>&lt;property name=&quot;build.packages&quot; location=
      &quot;${deploy.dir}/share/globus_wsrf_common/build-packages.xml&quot;/&gt;
...
&lt;target name=&quot;undeploy&quot;&gt;
  &lt;ant antfile=&quot;${build.packages}&quot; target=&quot;undeployGar&quot;&gt;
    &lt;property name=&quot;gar.id&quot; value=&quot;mygar&quot;/&gt;
  &lt;/ant&gt;
&lt;/target&gt;</screen>
        <para>The <computeroutput>gar.id</computeroutput> property must be passed. This property specifies the base name of the gar to undeploy.
</para>
      </section>
    </section>
  </section>

  <section id="CreatingLaunchers">
    <title>Generating launcher scripts</title>
    <para>Bourne Shell and Windows batch scripts can be automatically generated to hide the details of launching a Java program from the command line. 
</para>
    <para>To generate such a command line script, write a Ant task that calls the <computeroutput>generateLauncher</computeroutput> target
    in <computeroutput>$GLOBUS_LOCATION/share/globus_wsrf_common/build-launcher.xml</computeroutput>.
    The following properties/parameters must be specified: </para>
    <itemizedlist>
      <listitem>
        <simpara><emphasis>
            <computeroutput>${launcher-name}</computeroutput>
          </emphasis> - the base name of script to generate.</simpara>
      </listitem>
      <listitem>
        <simpara><emphasis>
            <computeroutput>${class.name}</computeroutput>
          </emphasis> - the name of Java class the script must call.</simpara>
      </listitem>
    </itemizedlist>
    <para>
For example:
</para>
<screen>...
&lt;property name=&quot;env.GLOBUS_LOCATION&quot; value=&quot;.&quot;/&gt;
&lt;property name=&quot;deploy.dir&quot; location=&quot;${env.GLOBUS_LOCATION}&quot;/&gt;
&lt;property name=&quot;abs.deploy.dir&quot; location=&quot;${deploy.dir}&quot;/&gt;
&lt;property name=&quot;build.launcher&quot;
        location=&quot;${abs.deploy.dir}/share/globus_wsrf_common/build-launcher.xml&quot;&gt;
...
&lt;ant antfile=&quot;${build.launcher}&quot; target=&quot;generateLauncher&quot;&gt;
  &lt;property name=&quot;launcher-name&quot; value=&quot;myClient&quot;/&gt;
  &lt;property name=&quot;class.name&quot; value=&quot;org.mypackage.MyClient&quot;/&gt;
&lt;/ant&gt;</screen>
<para>It is also possible to specify default JVM options and command line options
via the <computeroutput>default.jvm.options</computeroutput> and <computeroutput>default.cmd.line</computeroutput> parameters.</para>
    <para>In general the generation of the command line scripts is done in the <computeroutput>post-deploy.xml</computeroutput> script
    during GAR deployment (<xref linkend="deployGar"/>). </para>
  </section>

  </section>


 <section id="s-javawscore-developer-testing">
    <title>Testing</title>
    <para>Tests in the Java WS Core are based on the <ulink url="http://www.junit.org/">JUnit</ulink> API. JUnit must first be installed with Ant. To install JUnit with Ant copy the <computeroutput>junit.jar</computeroutput> found in JUnit distribution to the <computeroutput>$ANT_HOME/lib</computeroutput> directory.  Alternatively, you can add the <computeroutput>junit.jar</computeroutput> to your
CLASSPATH, or source <filename>$GLOBUS_LOCATION/etc/globus-devel-env.sh</filename>.
</para>
    <section id="s-javawscore-developer-writingtests">
      <title>Writing Tests</title>
      <para>Always make sure to group your tests under the <computeroutput>PackageTests.java</computeroutput> and/or <computeroutput>SecurityTests.java</computeroutput> test
suites. Put all tests that require any type of credentials in the <computeroutput>SecurityTests.java</computeroutput> test
suite. 
</para>
      <para>If you are writing  basic unit tests that do not require a container to run,
just use the regular JUnit classes to write such tests. </para>
      <para>If you are writing
    tests that require a container to execute, use the <computeroutput>org.globus.wsrf.test.GridTestCase</computeroutput> class
    instead of <computeroutput>junit.framework.TestCase</computeroutput> as your base class for your
    tests. Also ensure your <computeroutput>PackageTests.java</computeroutput> or <computeroutput>SecurityTests.java</computeroutput> extends
    the <computeroutput>org.globus.wsrf.test.GridTestSuite</computeroutput> instead of <computeroutput>junit.framework.TestSuite</computeroutput>. </para>
      <para>The <computeroutput>org.globus.wsrf.test.GridTestSuite</computeroutput> and <computeroutput>org.globus.wsrf.test.GridTestCase</computeroutput> <emphasis>must</emphasis> be
used together. The <computeroutput>org.globus.wsrf.test.GridTestCase</computeroutput> class exposes
a <computeroutput>TEST_CONTAINER</computeroutput> variable that can be used to obtain the URL of
the container (<computeroutput>TEST_CONTAINER.getBaseURL()</computeroutput>). By default an embedded
container will be started for all tests in the test suite. To specify an external
container, pass the <computeroutput>-Dweb.server.url=&lt;base.url&gt;</computeroutput> system property
on the <computeroutput>java</computeroutput> command line.
</para>
    </section>
    <section id="s-javawscore-developer-runningtests">
      <title>Running Tests</title>
      <para>To execute the tests on the Java WS Core install, run the following (assuming
  the tests have been deployed into that install):
</para>
<screen>$ cd $GLOBUS_LOCATION
$ ant -f share/globus_wsrf_test/runtests.xml runServer -Dtests.jar=&lt;test.jar&gt;</screen>
<para>Where <computeroutput>&lt;test.jar&gt;</computeroutput> is an <emphasis>absolute</emphasis> path to the jar file that contains the tests. </para>
      <para>By default, the tests that use a container will try to access a container
running at <computeroutput>http://localhost:8080/wsrf/services/</computeroutput>. </para>
      <para>To specify a
    different container, use the <computeroutput>-Dtest.server.url=&lt;url&gt;</computeroutput> property.
</para>
      <para>To execute PackageTests only, specify <computeroutput>-DbasicTestsOnly=true</computeroutput>.
</para>
      <para>To execute SecurityTests only, specify <computeroutput>-DsecurityTestsOnly=true</computeroutput>. </para>
      <para>The test reports will be put in the <computeroutput>$GLOBUS_LOCATION/share/globus_wsrf_test/tests/test-reports</computeroutput> directory
            by default. A different test reports directory can be specified
    by passing <computeroutput>-Djunit.reports.dir=&lt;directory&gt;</computeroutput>.
</para>
<para>
 Use <computeroutput>-Djunit.jvmarg</computeroutput> to pass arbitrary properties to the testing JVM. Example:</para>
<screen>$ ant -f share/... -Djunit.jvmarg="-Dorg.globus.wsrf.container.server.id=myServerID"</screen>
<para></para>
    </section>
  </section>


 <section id="s-javawscore-developer-other">
 <title>Other</title>

  <section id="s-javawscore-developer-CustomExpressionEval">
    <title>Adding a new query/topic expression evaluator</title>
    <para>Java WS Core allows for custom query/topic expression evaluators to be plugged in. The process of adding a new query/topic expression evaluator is composed of three steps:</para>
    <section id="s-javawscore-developer-implementation">
      <title>Step 1: Implement the evaluator </title>
      <table>
        <title>Evaluator interfaces</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>If the evaluator is a... </entry>
              <entry>then it must implement: </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>query expression evaluator </entry>
              <entry>
                <computeroutput>org.globus.wsrf.query.ExpressionEvaluator</computeroutput>
              </entry>
            </row>
            <row>
              <entry>topic expression evaluator </entry>
              <entry>
                <computeroutput>org.globus.wsrf.topicexpression.TopicExpressionEvaluator</computeroutput>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="s-javawscore-developer-registration">
      <title>Step 2: Register the evaluator </title>
      <para>The evaluators must be registered in order for Java WS Core to recognize them.
  The registration is done through the JNDI configuration file. The expression
  evaluators must be deployed as global resources under a specific subcontext. </para>
      <section>
        <title>Registering query expression evaluators </title>
        <para>The query expression evaluators must be deployed as global resources
  under the <emphasis>
            <computeroutput>query/eval/</computeroutput>
          </emphasis> subcontext in the JNDI configuration
  file. </para>
        <para>
Example:
</para>
<screen>&lt;global&gt;
  &lt;resource <emphasis role="bold">name</emphasis>=&quot;query/eval/<emphasis>MyQueryExpressionEval</emphasis>&quot;
            <emphasis role="bold">type</emphasis>=&quot;<emphasis>foo.bar.MyQueryExpressionEvaluator</emphasis>&quot;&gt;
    &lt;resourceParams&gt;
      &lt;parameter&gt;
        &lt;name&gt;factory&lt;/name&gt;
        &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
      &lt;/parameter&gt;
    &lt;/resourceParams&gt;
  &lt;/resource&gt;
&lt;/global&gt;</screen>
<para>
Where the <computeroutput>&lt;resource&gt;</computeroutput> attribute:
</para>
<informaltable>
            <tgroup cols="2">
              <tbody>
                <row>
                  <entry>
                    <computeroutput>name</computeroutput>
                  </entry>
                  <entry>Specifies the name of the evaluator in JNDI space. The name can be arbitrary as long as it is unique and is in the right subcontext as explained above.</entry>
                </row>
                <row>
                  <entry>
                    <computeroutput>type</computeroutput>
                  </entry>
                  <entry>Specifies the class that implements the expression evaluator.</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
      </section>
      <section>
        <title>Registering topic expression evaluators </title>
        <para>Topic expression evaluators must be deployed as global resources under
  the <emphasis>
            <computeroutput>topic/eval/</computeroutput>
          </emphasis> subcontext in the JNDI configuration file. </para>
        <para>Example:</para>
<screen>&lt;global&gt;
  &lt;resource <emphasis role="bold">name</emphasis>=&quot;topic/eval/<emphasis>MyTopicExpressionEval</emphasis>&quot;
            <emphasis role="bold">type</emphasis>=&quot;<emphasis>foo.bar.MyTopicExpressionEvaluator</emphasis>&quot;&gt;
    &lt;resourceParams&gt;
      &lt;parameter&gt;
        &lt;name&gt;factory&lt;/name&gt;
        &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
      &lt;/parameter&gt;
    &lt;/resourceParams&gt;
  &lt;/resource&gt;
&lt;/global&gt;</screen>
<para>
Where the <computeroutput>&lt;resource&gt;</computeroutput> attribute:
</para>
        <informaltable>
          <tgroup cols="2">
            <tbody>
              <row>
                <entry>
                  <computeroutput>name</computeroutput>
                </entry>
                <entry>Specifies the name of the evaluator in JNDI space. The name can be arbitrary as long as it is unique and is in the right subcontext as explained above.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>type</computeroutput>
                </entry>
                <entry>Specifies the class that implements the expression evaluator.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>
    <section id="s-javawscore-developer-registrationserializerdeserializer">
      <title>Step 3: Register the serializer/deserializer for the evaluator</title>
      <para>A serializer/deserializer must be registered for the dialect of the evaluator
  in order for the expression to be properly serialized and deserialized. The
  serializers/deserializers for the dialect are deployed as almost any other
  type mapping. In general, each type mapping specifies a type QName. For dialect
serializers/deserializers, that type QName takes a slightly different name.</para>
      <section>
        <title>Specifying the QName for query expression evaluators </title>
        <para>For query expression evaluators, that QName must have the local name part
    set to <emphasis>
            <computeroutput>QueryExpressionDialect</computeroutput>
          </emphasis> and
  namespace part set to the dialect of the query expression evaluator. </para>
        <para>Example: </para>
        <screen>&lt;typeMapping 
   encodingStyle=&quot;&quot; 
   deserializer=&quot;org.apache.axis.encoding.ser.SimpleDeserializerFactory&quot;
   serializer=&quot;org.apache.axis.encoding.ser.SimpleSerializerFactory&quot;
   type=&quot;java:java.lang.String&quot;
   qname=&quot;ns12:QueryExpressionDialect&quot; 
   xmlns:ns12=&quot;http://foo.bar/MyQueryDialect&quot;/&gt;</screen>
        <para>
  <note>
            <simpara>These type mappings must be deployed both on the client and the server.</simpara>
          </note>  </para>
      </section>
      <section>
        <title>Specifying the QName for topic expression evaluators </title>
        <para>For topic expression evaluators, that QName must have the local name part
  set to <emphasis>
            <computeroutput>TopicExpressionDialect</computeroutput>
          </emphasis> and
  namespace part set to the dialect of the topic expression evaluator. </para>
        <para>Example:
<screen>&lt;typeMapping 
   encodingStyle=&quot;&quot; 
   deserializer=&quot;org.apache.axis.encoding.ser.SimpleDeserializerFactory&quot;
   serializer=&quot;org.apache.axis.encoding.ser.SimpleSerializerFactory&quot;
   type=&quot;java:java.lang.String&quot;
   qname=&quot;ns12:TopicExpressionDialect&quot; 
   xmlns:ns12=&quot;http://foo.bar/MyTopicDialect&quot;/&gt;</screen>

<note>
            <simpara>These type mappings must be deployed both on the client and the server.</simpara>
          </note></para>
      </section>
    </section>
  <section id="s-javawscore-developer-GetCurrentMessageProvider">
    <title>Step 4: Configuring a helper serializer for GetCurrentMessageProvider</title>
    <para>
The standard <computeroutput>GetCurrentMessageProvider</computeroutput> might not know how to properly
serialize the notification message currently associated with the specified topic.
The <computeroutput>GetCurrentMessageProvider</computeroutput> can be configured to use a helper
serializer for a given notification message type. </para>
    <para>To configure such a helper serializer,
  define the following global resource in your <computeroutput>deploy-jndi.xml</computeroutput> configuration
  file:</para>
<screen>&lt;global&gt;
  &lt;resource
    <emphasis role="bold">name</emphasis>=&quot;providers/GetCurrentMessageProvider/<emphasis>foo.bar.MyNotificationMessage</emphasis>&quot;
    <emphasis role="bold">type</emphasis>=&quot;<emphasis>foo.bar.MyMessageSerializer</emphasis>&quot;&gt;
    &lt;resourceParams&gt;
      &lt;parameter&gt;
        &lt;name&gt;factory&lt;/name&gt;
        &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
      &lt;/parameter&gt;
    &lt;/resourceParams&gt;
  &lt;/resource&gt;
&lt;/global&gt;</screen>
<para>
Where the <computeroutput>&lt;resource&gt;</computeroutput> attribute:
</para>
    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>
              <computeroutput>name</computeroutput>
            </entry>
            <entry>Must start with <emphasis>
                <computeroutput>providers/GetCurrentMessageProvider/</computeroutput>
              </emphasis> and must end with the full class name of the notification message.</entry>
          </row>
          <row>
            <entry>
              <computeroutput>type</computeroutput>
            </entry>
            <entry>Specifies the class that implements the <computeroutput>org.globus.wsrf.encoding.ObjectConverter</computeroutput> interface and is responsible for serializing the notification message. The <computeroutput>GetCurrentMessageProvider</computeroutput> will use the type of the notification message to find the helper serializer.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
 </section>
  </section>
</section>
<section id="s-javawscore-developer-tutorials">
  <title>Tutorials</title>
  <para>
<itemizedlist>
      <listitem>
        <simpara>
          <ulink url="http://gdp.globus.org/gt4-tutorial/">The Globus Toolkit 4 Programmer&apos;s Tutorial by Borja Sotomayor</ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="http://ds.informatik.uni-marburg.de/~matthew/GT4AnnotationTutorial.html">Writing a GT4 Service Using Java Annotations (in 5 easy steps) by Matthew Smith and Bernd Freisleben</ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="http://www.qub.ac.uk/escience/howtos/GT3%20to%20GT4%20Version%200.3.htm">GT3.2 to GT4 Migration: A First HOWTO by Terry Harmer and Julie McCabe</ulink>
        </simpara>
      </listitem>
    </itemizedlist>
</para>
</section>

<section id="s-javawscore-developer-debugging"  xreflabel="Debugging and Logging">
  <title>Debugging</title>
  <para>Logging in the Java WS Core is based on the <ulink url="http://jakarta.apache.org/commons/logging/">Jakarta Commons Logging</ulink> API. Commons Logging provides a consistent interface for instrumenting source code while at the same time allowing the user to plug-in a different logging implementation. Currently we use <ulink url="http://logging.apache.org/log4j/">Log4j</ulink> as a logging implementation. Log4j uses a separate configuration file to configure itself. Please see Log4j documentation for details on the <ulink url="http://logging.apache.org/log4j/docs/api/org/apache/log4j/PropertyConfigurator.html#doConfigure(java.lang.String, org.apache.log4j.spi.LoggerRepository)">configuration file format</ulink>.
</para>
  <para>Java WS Core is deployed with two Log4j configuration files:</para>
  <itemizedlist>
    <listitem>
      <simpara><computeroutput>$GLOBUS_LOCATION/container-log4j.properties</computeroutput> (configures logging for the standalone container)</simpara>
    </listitem>
    <listitem>
      <simpara><computeroutput>$GLOBUS_LOCATION/log4j.properties</computeroutput> (configures logging for everything else besides the standalone container)</simpara>
    </listitem>
  </itemizedlist>
  <section id="s-javawscore-developer-tracingsoapmessages">
    <title>Tracing SOAP messages</title>
    <section id="s-javawscore-developer-usingtcpmon">
      <title>Using TcpMonitor</title>
      <para>To trace SOAP messages on the wire you can use TcpMon from <glossterm linkend="axis">Apache Axis</glossterm>. After setting the environment using <computeroutput>$GLOBUS_LOCATION/etc/globus-dev-env.[sh|csh|bat]</computeroutput> run: 
</para>
<screen>$ java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]</screen>
<para>If no arguments are used, you have to fill out these values in the GUI. Make
  sure to also start the standalone container with the proxy
  server port option set to the <computeroutput>listenPort</computeroutput> value.</para>
    </section>
    <section id="s-javawscore-developer-usingmessagelogginghandler">
      <title>Using MessageLoggingHandler</title>
      <para>Another method for logging SOAP messages is to add the <computeroutput>org.globus.wsrf.handlers.MessageLoggingHandler</computeroutput> to the request or response chain in the <computeroutput>server-config.wsdd</computeroutput> or <computeroutput>client-config.wsdd</computeroutput> files. </para>
      <para>For example:</para>
<screen>&lt;requestFlow&gt;  
  ...  
  &lt;handler type=&quot;java:org.globus.wsrf.handlers.MessageLoggingHandler&quot;/&gt;   
  ...
&lt;/requestFlow&gt;</screen>
<para>Then you must enable logging for this handler class in the appropriate <computeroutput>log4j.properties</computeroutput> files and change the logging level to DEBUG: </para>
<screen>log4j.category.org.globus.wsrf.handlers.MessageLoggingHandler=DEBUG</screen>
<para></para>
    </section>
    <section id="s-javawscore-developer-enablinglogging">
      <title>Enabling logging for Axis classes</title>
      <para>Another method for tracing SOAP messages is to enable logging for selected
Axis classes. Add the following lines to the appropriate <computeroutput>log4j.properties</computeroutput> files: </para>
<screen>log4j.category.org.apache.client.Call=DEBUG
log4j.category.org.apache.axis.transport.http.HTTPSender=DEBUG
# enable the following logger for HTTPS/HTTPG transport handlers
log4j.category.org.globus.axis.axis.transport=DEBUG</screen>
<para>This will log Axis client side calls and Axis HTTP messages.
</para>
    </section>
  </section>
  <section id="s-javawscore-developer-debugginglog4j">
    <title>Debugging Log4j</title>
    <para>If you are having problems with configuring Log4j, you can enable internal
  Log4j debugging by adding <computeroutput>-Dlog4j.debug=true</computeroutput> option on the <computeroutput>java</computeroutput> command
  line or passing it via the <computeroutput>GLOBUS_OPTIONS</computeroutput> environment
  property.</para>
  </section>
</section>
<section id="s-javawscore-developer-troubleshooting">
  <title>Troubleshooting</title>
  <section id="s-javawscore-developer-nosocket">
    <title>No socket factory for &apos;https&apos; protocol</title>
    <para>When a client fails with the following exception:</para>
<screen>java.io.IOException: No socket factory for &apos;https&apos; protocol
    at org.apache.axis.transport.http.HTTPSender.getSocket(HTTPSender.java:179)
    at org.apache.axis.transport.http.HTTPSender.writeToSocket(HTTPSender.java:397)
    at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:135)</screen>
<para>
add the following to the client:</para>
<screen>import org.globus.axis.util.Util;
...
static {
    Util.registerTransport();
}
...</screen>
</section>
  <section id="s-javawscore-developer-notransport">
    <title>No client transport named &apos;https&apos; found</title>
    <para>When a client fails with the following exception:</para>
<screen>No client transport named &apos;https&apos; found
   at org.apache.axis.client.AxisClient.invoke(AxisClient.java:170)
   at org.apache.axis.client.Call.invokeEngine(Call.java:2726)</screen>
<para>
The client is most likely loading an incorrect <computeroutput>client-config.wsdd</computeroutput> configuration file. Ensure that the GT4 installation directory is listed as a first entry in the <computeroutput>CLASSPATH</computeroutput> of the client. For example:</para>
<screen>CLASSPATH=/usr/local/globus-4.0.0:/foo/bar/others.jar:...</screen>
<para>If you are seeing this problem in Tomcat, copy the <computeroutput>client-config.wsdd</computeroutput> from the GT4 installation directory to the Web application's <computeroutput>WEB-INF/classes</computeroutput> directory.
</para>

<para></para>
  </section>
  <section id="s-javawscore-developer-general">
    <title>General troubleshooting information</title>
&Java_WS_Core_Troubleshooting_Frag;
  </section>
</section>
<section id="s-javawscore-developer-relateddocs">
  <title>Related Documentation</title>
  <para>
Overview material about WSRF and WSN and more information on 
the implemented WSDL and schema can be found 
<ulink url="http://www.globus.org/wsrf/">here</ulink>.
</para>
  <para>
Information about ongoing standards work can be found here: 
<itemizedlist>
      <listitem>
        <simpara>
          <ulink url="http://www.w3.org/2002/ws/addr/">WS-Addressing</ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wsrf">WS-ResourceFramework</ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wsn">WS-Notification</ulink>
        </simpara>
      </listitem>
    </itemizedlist>
</para>
</section>
<section id="s-javawscore-developer-miscellaneousinfo">
  <title>Appendices</title>

  <section id="s-javawscore-developer-ProxySupport">
    <title>Proxy support</title>
    <para>A basic proxy support is provided. The <emphasis>
        <computeroutput>org.globus.wsrf.proxy.port</computeroutput>
      </emphasis> system
property can be set to the port of the proxy server (the proxy server must run
on the same machine as the container). This will make any code that uses the <computeroutput>ServiceHost</computeroutput> or <computeroutput>AddressingUtils</computeroutput> API
return the address of the proxy server instead of the container. This could be
useful, for example, for debugging purposes.
The <emphasis>
        <computeroutput>org.globus.wsrf.proxy.port</computeroutput>
      </emphasis> system property can be passed to <computeroutput>globus-start-container</computeroutput> script via the <computeroutput>GLOBUS_OPTIONS</computeroutput> environment property. For example:
</para>
<screen> $ setenv GLOBUS_OPTIONS=&quot;-Dorg.globus.wsrf.proxy.port=5555&quot;
 $ globus-start-container</screen>
<para>Please note that not all of the code will obey the proxy port setting.
</para>
  </section>

</section>
