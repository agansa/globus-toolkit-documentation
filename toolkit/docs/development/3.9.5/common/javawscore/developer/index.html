<?php 
$title="GT 3.9.5 Java WS Core : Developer's Guide ";
include_once( "/mcs/www-unix.globus.org/include/globus_header.inc" ); ?>



<h1><?php echo $title; ?></h1>
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#archdes">Architecture and design overview</a></li>
  <li><a href="#pubinterfaces">Public interface</a></li>
  <li><a href="#scenarios">Usage scenarios</a> 
   <ul>
    <li><a href="#ApacheAddressing">Using Apache Addressing API</a></li>
    <li><a href="#NotificationConsumer">Notification Consumer</a></li>
    <li><a href="#EndpointInfo">Container Endpoint Information</a></li>
    <li><a href="#LocalInvocations">Local Invocations</a></li>
    <li><a href="#CustomExpressionEval">Custom Query/Topic Expression Evaluators</a></li>
    <li><a href="#GetCurrentMessageProvider">Notification Message Types and GetCurrentMessageProvider</a></li>
   </ul>
  </li>
  <li><a href="#tutorials">Tutorials</a></li>
  <li><a href="#features">Feature summary</a></li>
  <li><a href="#platforms">Tested platforms</a></li>
  <li><a href="#compatibility">Backward compatibility summary</a></li>
  <li><a href="#dependencies">Technology dependencies</a></li>
  <li><a href="#security_considerations">Security considerations</a> </li>
  <li><a href="#debugging">Debugging</a></li>
  <li><a href="#troubleshooting">Troubleshooting</a></li>
  <li><a href="#relateddocs">Related Documentation</a></li>
  <li><a href="#miscellaneousinfo">Miscellaneous information</a>
   <ul>
    <li><a href="#DocumentLiteral">Document/literal notes</a></li> 
    <li><a href="#OperationProvider">Operation provider details</a></li>
    <li><a href="#JNDIDetails">JNDI details</a></li>
    <li><a href="#WritingClients">Client notes</a></li>
    <li><a href="#ContextProperties">MessageContext properties</a></li>
    <li><a href="#testing">Writing and running tests</a></li>
    <li><a href="#gardetails">GAR</a></li>
    <li><a href="#CreatingLaunchers">Generating launcher scripts</a></li>
    <li><a href="#ProxySupport">Proxy support</a></li>
    <li><a href="#Activation">Lifecycle and activation</a></li>
   </ul>
  </li>
</ul>
<h2><a name="introduction"></a>Introduction</h2>
<p>This guide contains information of interest to developers working with Java
  WS Core. It provides reference information for application developers, including
  APIs, architecture, procedures for using the APIs and code samples.
</p>
<h2><a name="archdes"></a>Architecture and design overview</h2>

<ul>
  <li>Java WS Core Design Document [<a href="JavaWSCoreDesign.doc">doc</a> | pdf ]</li>
  <li>Java WS Core UML [<a href="JavaWSCoreUML.vsd">vsd</a>]</li>
</ul>

<h2><a name="pubinterfaces"></a>Public interface</h2>
<p>The semantics and syntax of the APIs and WSDL for the component, along with
  descriptions of domain-specific structured interface data, can be found in
  the <a href="../Java_WS_Core_Public_Interfaces.html">public interface guide</a>.</p>

<h2><a name="scenarios"></a>Usage scenarios</h2>
<ul>
  <li><a href="#ApacheAddressing">Using Apache Addressing API</a></li>
  <li><a href="#call">Call object</a></li>
  <li>  <a href="#addressinglocator">AddressingLocator class</a></li>
  <li><a href="#referenceproperties">ReferenceProperties</a></li>
  <li><a href="#NotificationConsumer">Notification Consumer</a></li>
  <li><a href="#EndpointInfo">Container Endpoint Information</a></li>
  <li><a href="#LocalInvocations">Local Invocations</a></li>
  <li><a href="#CustomExpressionEval">Custom Query/Topic Expression Evaluators</a></li>
  <li><a href="#GetCurrentMessageProvider">Notification Message Types and GetCurrentMessageProvider</a></li>
</ul>
<h3><a name="ApacheAddressing">Using Apache Addressing API</a></h3>

<p>
The WS-RF and WS-N specifications distributed with Java WS Core use WS-Addressing (the March 2004 version of the specification) for addressing services and resources. Java WS Core uses <a href="http://ws.apache.org/ws-fx/addressing/">Apache
Addressing</a> library for WS-Addressing support. The API are pretty straightforward and easy to use. Most of the work is done in <code>AddressingHandler</code> deployed in the client and server configuration files. See Apache Addressing documentation for details.

<h3><a name="call"></a>Call object</h3>

<p>If you are using the <code>javax.xml.rpc.Call</code> object directly, you can pass the addressing information by setting a <code>Constants.ENV_ADDRESSING_REQUEST_HEADERS</code> property on the call object. </p>
<p>For example: </p>
<pre>
 Service service = new Service();
 Call call = (Call) service.createCall();

 String url = "http://localhost:8080/axis/services/Version";

 AddressingHeaders headers = new AddressingHeaders();
 headers.setTo(new To(url));

 // pass the addressing info to the addressing handler
 call.setProperty(Constants.ENV_ADDRESSING_REQUEST_HEADERS, headers);

 call.setTargetEndpointAddress(new URL(url));
 call.setOperationName(new QName(url, "getVersion")); // url here is just a namespace

 String ret = (String) call.invoke(new Object[]);
</pre>

<h3><a name="addressinglocator"></a>AddressingLocator class</h3>

<p>The Apache Addressing library also contains a version of Axis' WSDL2Java tool.
  It extends the Axis' WSDL2Java tool functionality by generating, in addition
  to all the regular classes, the <code>&lt;service&gt;Addressing</code> interface
and <code>&lt;service&gt;AddressingLocator</code> class. </p>
<p>The <code>AddressingLocator</code>  class can be used to get a stub for a service by passing Apache Addressing <code>EndpointReferenceType</code> parameter. </p>
<p>For example: </p>
<pre>
 String url = "http://localhost:8080/axis/services/Version";

 EndpointReferenceType epr = new EndpointReferenceType();
 epr.setAddress(new Address(url));

 VersionServiceAddressingLocator locator =
      new VersionServiceAddressingLocator();

 VerionServicePortType port = locator.getVersionPort(epr);

 port.getVersion();
</pre>

<h3><a name="referenceproperties"></a>ReferenceProperties</h3>

<p>In the WS-RF, WS-N specifications, the WS-Addressing <code>ReferenceProperties</code> are used to carry resource identity information. The resource identity can be anything as long as it serializes as a XML element. The <code>ReferenceProperties</code> are serialized as separate SOAP headers in the SOAP envelope.
</p>
<p> Apache Addressing library only allows a DOM <code>Element</code> or a <code>SOAPElement</code> to
  be a reference property. </p>
<p>For example, create <code>ReferencePropertiesType</code> and fill it with resource key info: </p>
<pre>
 // this will be a reference property
 SimpleResourceKey key = new SimpleResourceKey(Counter.KEY, "123");

 ReferencePropertiesType props = new ReferencePropertiesType();

 // convert to SOAPElement and add to the list
 props.add(key.toSOAPElement()); 
 ...
</pre>
<p>
Then pass it to <code>AddressingHeaders</code>:
</p>
<pre>
 ...
 Service service = new Service();
 Call call = (Call) service.createCall();

 String url = "http://localhost:8080/axis/services/Version";

 AddressingHeaders headers = new AddressingHeaders();
 headers.setTo(new To(url));
 <b>headers.setReferenceProperties(props);</b>

 // pass the addressing info to the addressing handler
 call.setProperty(Constants.ENV_ADDRESSING_REQUEST_HEADERS, headers);

 call.setTargetEndpointAddress(new URL(url));
 call.setOperationName(new QName(url, "getVersion")); // url here is just a namespace

 String ret = (String) call.invoke(new Object[]);
</pre>
<p>
Or set it on <code>EndpointReferenceType</code>:
</p>
<p>
</p>
<pre>
 ...
 String url = "http://localhost:8080/axis/services/Version";

 EndpointReferenceType epr = new EndpointReferenceType();
 epr.setAddress(new Address(url));
 <b>epr.setProperties(props);</b>

 VersionServiceAddressingLocator locator =
     new VersionServiceAddressingLocator();

 VerionServicePortType port = locator.getVersionPort(epr);

 port.getVersion();
</pre>

<h3><a name="NotificationConsumer">Notification Consumer</a></h3>
<p>
There are a few steps involved in setting up and receiving notifications:</p>
<ul>
 <li><a href="#callback">Callback implementation</a></li>
 <li><a href="#notificationconsumermgr">NotificationConsumerManager</a></li>
 <li><a href="#registrationcallback">Registration of callback</a></li>
 <li><a href="#subscription">Subscription</a></li>
 <li><a href="#cleanup">Clean up</a></li>
</ul>


<h4><a name="callback"></a>Callback implementation</h4>
<p>
The notification consumer application must provide an implementation of the <code>org.globus.wsrf.NotifyCallback</code> interface. The <code>deliver</code> function of the interface will be invoked whenever a notification for that consumer arrives. The <code>message</code> parameter will either be of <code>org.w3c.dom.Element</code> type if the message type was unknown or some object mapped to the type of the message. <br>
Please note that the <code>deliver</code> function should be thread-safe as multiple notifications might come at once. Notifications might also come unordered and some might even be lost.
</p>

<h4><a name="notificationconsumermgr"></a>NotificationConsumerManager</h4>
<p>
In order to facilitate the receipt of notifications a <code>NotificationConsumerManager</code> needs to be started. The <code>NotificationConsumerManager</code> starts an embedded container through which the notifications are handled. To start a <code>NotificationConsumerManager</code> do:
</p>
<pre>
 import org.globus.wsrf.NotificationConsumerManager; 
 ...

 NotificationConsumerManager consumer = null;
 try {
    consumer = NotificationConsumerManager.getInstance();
    consumer.startListening();
    ...
</pre>

<h4><a name="registrationcallback"></a>Registration of callback</h4>
<p>
The callback implementation needs to be registered with the <code>NotificationConsumerManager</code> (once it is started) using the <code>createNotificationConsumer</code> function. The <code>createNotificationConsumer</code> function returns an endpoint for this notification consumer. Example:
</p>
<pre>
 import org.globus.wsrf.NotifyCallback;
 import org.apache.axis.message.addressing.EndpointReferenceType;
 ...

    MyCallback callback = new MyCallback();
    EndpointReferenceType consumerEPR =
        consumer.createNotificationConsumer(callback);
    ...

 class MyCallback implements NotifyCallback {
   ....
 }
</pre>

<h4><a name="subscription"></a>Subscription</h4>
<p>
The endpoint returned by the <code>createNotificationConsumer</code> function can be then passed to the subscribe call. Example:
</p>
<pre>
 import org.oasis.wsn.TopicExpressionType;
 import org.oasis.wsn.Subscribe;
 import org.oasis.wsn.SubscribeResponse;
 import org.globus.wsrf.WSNConstants;
 import org.globus.wsrf.WSRFConstants;
 ...

    TopicExpressionType topicExpression = new TopicExpressionType();
    topicExpression.setDialect(WSNConstants.SIMPLE_TOPIC_DIALECT);
    topicExpression.setValue(WSRFConstants.TERMINATION_TIME);

    Subscribe request = new Subscribe();
    request.setUseNotify(Boolean.TRUE);
    request.setConsumerReference(consumerEPR);
    request.setTopicExpression(topicExpression);

    SubscribeResponse subResponse = port.subscribe(request);
    ...
</pre>

<h4><a name="cleanup"></a>Clean up</h4>
<p>
Once done with the notifications make sure to explicitly destroy the subscription resource or set its termination time. <br>
For example:
</p>
<pre>
 import org.globus.wsrf.core.notification.SubscriptionManager;
 import org.globus.wsrf.core.notification.service.SubscriptionManagerServiceAddressingLocator;
 import org.oasis.wsrf.lifetime.Destroy;
 ...

    SubscriptionManagerServiceAddressingLocator sLocator =
        new SubscriptionManagerServiceAddressingLocator();
    SubscriptionManager manager = sLocator.getSubscriptionManagerPort(
                        subResponse.getSubscriptionReference());
    manager.destroy(new Destroy());
    ...
</pre>


<p>
Also, please ensure to call (especially in error cases) <b><code>NotificationConsumerManager.removeNotificationConsumer()</code></b> function to unregister the callbakc from the <code>NotificationConsumerManager</code>. In addition make sure to always call the <b><code>NotificationConsumerManager.stopListening()</code></b> function when finished using the <code>NotificationConsumerManager</code>. Otherwise, some resources might not be released. <br>
For example:
</p>
<pre>
    ...
 } catch(Exception e) {
    ...
 } finally {
    if (consumer != null) {
       try { consumer.stopListening(); } catch (Exception ee) {}
    }
 }
</pre>

<h3><a name="EndpointInfo">Container Endpoint Information</a></h3>
<p>
In most cases, a service will need to return an endpoint information of the container to a client. Unfortunately, getting that information might not be easy. The only reliable way of getting the container endpoint information is to extract it from the <code>MessageContext.TRANS_URL</code> property of the <code>MessageContext/ResourceContext</code> associated with the current thread. We provide <code>ServiceHost</code> API to obtain that information easily, for example:
</p>
<pre>
 import org.globus.wsrf.container.ServiceHost;
 ...
 URL containerBaseUrl = ServiceHost.getBaseURL();
 ...
</pre>
<p>
The above will return the base container URL such as <code>http://localhost:8080/wsrf/services/</code>.
</p>
We also provide convenience API for creating WS-Addressing endpoints, for example:</p>
<pre>
 import org.apache.axis.message.addressing.EndpointReferenceType;
 import org.globus.wsrf.utils.AddressingUtils;
 ...
 EndpointReferenceType containerEndpoint = 
        AddressingUtils.createEndpointReference(null);
 ...
</pre>
<p>
The above will return the <code>EndpointReferenceType</code> object with the <code>Address</code> field set to the base container URL (as before) and empty reference properties.
</p>
<p>
<b>Note:</b> The <code>ServiceHost</code> API will return the correct information and <code>AddressingUtils</code> API will work correctly, only if called from the same thread as the service method was invoked from.
</p>

<h3><a name="LocalInvocations">Local Invocations</a></h3>

<p>
Services in the container can be invoked locally. Local invocations work just like remote invocations (all handlers are called, messages get serialized/deserialized) but messages do not travel over the network - everything happens in memory. 
</p>
<p>
Local invocations can only be made on the server side and only when a Axis MessageContext is associated with a current thread. URLs with "<i>local</i>" protocol name are used for local invocations. To invoke a service locally do:
</p>

<table border="1" cellpadding="5" cellspacing="0" width="100%" >
<tr>
<td valign="top">1</td>
<td valign="top">
<p>Register "<i>local</i>" protocol handler:</p>
<pre>
import org.globus.axis.transport.local.LocalTransportUtils;
...
<b>LocalTransportUtils.init();</b>
...
</pre>
</td>
</tr>

<tr>
<td valign="top">2</td>
<td valign="top">
<p>Create a service URL with "<i>local</i>" protocol:</p>
<pre>
URL url = new URL(<b>"local:///wsrf/services/MyService"</b>);
</pre>
</td>
</tr>

<tr>
<td valign="top">3</td>
<td valign="top">
<p>Configure the service stub for local invocation and make the call:</p>
<pre>
MyServiceAddressingLocator locator = 
       new MyServiceAddressingLocator();
MyService port = locator.getMyServicePort(url);

<b>LocalTransportUtils.enableLocalTransport((Stub)port);</b>

port.hello();
</pre>
</table>

<h3><a name="CustomExpressionEval">Custom Query/Topic Expression Evaluators</a></h3>
<p>
Java WS Core allows for custom query/topic expression evaluators to be plugged in. The process of adding a new query/topic expression evaluator is composed of three steps:</p>
<ul>
 <li><a href="#implementation">Implementation of the evaluator</a></li>
 <li><a href="#registration">Registration of the evaluator</a></li>
 <li><a href="#registrationserializerdeserializer">Registration of the serializer/deserializer for the evaluator</a></li>
</ul>


<h4><a name="implementation"></a>Implementation of the evaluator </h4>
<p>
The query expression evaluators must implement the <code>org.globus.wsrf.query.ExpressionEvaluator</code> while the topic expression evaluators must implement the <code>org.globus.wsrf.topicexpression.TopicExpressionEvaluator</code> interface.
</p>

<h4><a name="registration"></a>Registration of the evaluator </h4>
<p>
The evaluators must be registered in order for Java WS Core to recognize them. The registration is done through the JNDI configuration file. The expression evaluators must be deployed as global resources under a specific subcontext. The query expression evaluators they must be put under <b><code>query/eval/</code></b> subcontext while the topic expression evaluators must be put under <b><code>topic/eval/</code></b> subcontext. 
</p>
<p>
Example of query expression evaluator registration:
</p>
<pre>
 &lt;global&gt;
  &lt;resource name="query/eval/<b>MyQueryExpressionEval</b>"
            type="<b>foo.bar.MyQueryExpressionEvaluator</b>">
    &lt;resourceParams&gt;
     &lt;parameter&gt;
      &lt;name&gt;factory&lt;/name&gt;
      &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
     &lt;/parameter&gt;
    &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</pre>
<p>
Example of topic expression evaluator registration:
</p>
<pre>
 &lt;global&gt;
  &lt;resource name="topic/eval/<b>MyTopicExpressionEval</b>"
            type="<b>foo.bar.MyTopicExpressionEvaluator</b>">
    &lt;resourceParams&gt;
     &lt;parameter&gt;
      &lt;name&gt;factory&lt;/name&gt;
      &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
     &lt;/parameter&gt;
    &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</pre>
<p>
Please note that the <b><code>type</code></b> attribute specifies the class that implements the expression evaluator. The <b><code>name</code></b> attribute specifies the name of the evaluator in JNDI space. The name can be arbitrary as long as it is unique and is in the right subcontext as explained above.
</p>
<h4><a name="registrationserializerdeserializer"></a>Registration  of the serializer/deserializer for the evaluator</h4>
<p>
A serializer/deserializer must be registered for the dialect of the evaluator in order for the expression to be properly serialized and deserialized. The serializers/deserializers for the dialect are deployed as almost any other type mapping. In general each type mapping specifies a type QName. For dialect serializers/deserializers that type QName takes a slightly different name.<br>
In case of query expression evaluator that QName must have the local name part set to <b><code>QueryExpressionDialect</code></b> and namespace part set to the dialect of the query expression evaluator. For example:
</p>
<pre>
 &lt;typeMapping 
    encodingStyle="" 
    deserializer="org.apache.axis.encoding.ser.SimpleDeserializerFactory"
    serializer="org.apache.axis.encoding.ser.SimpleSerializerFactory"
    type="java:java.lang.String"
    qname="ns12:QueryExpressionDialect" 
    xmlns:ns12="http://foo.bar/MyQueryDialect"/&gt;
</pre>
<p>
Similarly, in case of topic expression evaluator that QName must have the local name part set to <b><code>TopicExpressionDialect</code></b> and namespace part set to the dialect of the topic expression evaluator. For example:
</p>
<pre>
 &lt;typeMapping 
    encodingStyle="" 
    deserializer="org.apache.axis.encoding.ser.SimpleDeserializerFactory"
    serializer="org.apache.axis.encoding.ser.SimpleSerializerFactory"
    type="java:java.lang.String"
    qname="ns12:TopicExpressionDialect" 
    xmlns:ns12="http://foo.bar/MyTopicDialect"/&gt;
</pre>
<p>
Please note that these type mappings must be deployed both on the client and the server. 
</p>


<h3><a name="GetCurrentMessageProvider">Notification Message Types and GetCurrentMessageProvider</a></h3>
<p>
The standard <code>GetCurrentMessageProvider</code> might not know how to property serialize the notification message currently associated with the specified topic. The <code>GetCurrentMessageProvider</code> can be configured use a helper serializer for a given notification message type. To configure such helper serializer define the following global resource in your <code>deploy-jndi.xml</code> configuration file:
</p>
<pre>
 &lt;global&gt;
   &lt;resource
    name="providers/GetCurrentMessageProvider/<b>foo.bar.MyNotificaionMessage</b>"
    type="<b>foo.bar.MyMessageSerializer</b>"&gt;
      &lt;resourceParams&gt;
        &lt;parameter&gt;
          &lt;name&gt;factory&lt;/name&gt;
          &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
        &lt;/parameter&gt;
      &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</pre>
<p>
The <code>type</code> attribute specifies the class that implements the <code>org.globus.wsrf.encoding.ObjectConverter</code> interface and is responsible for serializing the notification message. The <code>name</code> attribute must start with <b><code>providers/GetCurrentMessageProvider/</code></b> and must end with the full class name of the notification message. The <code>GetCurrentMessageProvider</code> will use the type of the notification message to find the helper serializer.
</p>

<h2><a name="tutorials"></a>Tutorials</h2>
<p>
<ul>
  <li>
   <a href="http://gdp.globus.org/gt4-tutorial/">The Globus Toolkit 4 Programmer's Tutorial by Borja Sotomayor</a>
  </li>
</ul>
<h2><a name="features"></a>Feature summary</h2>
<?php
include_once( "./../Java_WS_Core_Feature_Summary_Frag.html" );
?>
<h2><a name="platforms"></a>Tested platforms</h2>
<?php
include_once( "../Java_WS_Core_Platform_Summary_Frag.html" );
?>
<h2><a name="compatibility"></a>Backward compatibility summary</h2>
<?php
include_once( "./../Java_WS_Core_Compatibility_Summary_Frag.html" );
?>
<h2><a name="dependencies"></a>Technology dependencies</h2>
<?php
include_once( "./../Java_WS_Core_Dependencies_Summary_Frag.html" );
?>
<h2><a name="security_considerations"></a>Security Considerations </h2>
<p>
  <?php
include_once( "./../Java_WS_Core_Security_Considerations_Frag.html" );
?>
</p>
<h2><a name="debugging"></a>Debugging</h2>

<p>Logging in the Java WS Core is based on the <a href="http://jakarta.apache.org/commons/logging/">Jakarta Commons Logging</a> API. Commons Logging provides a consistent interface for instrumenting source code while at the same time allowing the user to plug-in a different logging implementation. Currently we use <a href="http://logging.apache.org/log4j/">Log4j</a> as a logging implementation. Log4j uses a separate configuration file to configure itself. Please see Log4j documentation for details on the <a href="http://logging.apache.org/log4j/docs/api/org/apache/log4j/PropertyConfigurator.html#doConfigure(java.lang.String, org.apache.log4j.spi.LoggerRepository)">configuration file format</a>.
</p>
<p>
Java WS Core is deployed with two Log4j configuration files:</p>
<ul>
 <li>
   <code>$GLOBUS_LOCATION/container-log4j.properties</code> (configures logging
   for the standalone container)</li>
 <li>
   <code>$GLOBUS_LOCATION/log4j.properties</code> (configures logging for everything
   else besides the standalone container)</li>
</ul>


<h4><a name="tracingsoapmessages"></a>Tracing SOAP messages</h4>

<p>There are three methods for tracing SOAP messages: </p>
 <ul>
   <li><a href="#usingtcpmon">Using TcpMonitor</a>
   <li><a href="#usingmessagelogginghandler">Using MessageLoggingHandler</a>
   <li><a href="#enablinglogging">Enabling logging for Axis classes</a>. 
 </ul>


<h5><a name="usingtcpmon"></a>Using TcpMonitor</h5>

<p>
To trace SOAP messages on the wire you can use TcpMon from Apache Axis. After setting the environment using <code>$GLOBUS_LOCATION/etc/globus-dev-env.[sh|csh|bat]</code> run: 
</p>
<pre> $ java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]</pre>

<p>If no arguments are used, you have to fill out these values in the GUI. Make
  sure to also start the standalone container with the <a href="../Java_WS_Core_Public_Interfaces.html#SUPPORTED_GLOBUS_OPTIONS">proxy
  server port</a> option set to the <code>listenPort</code> value.</p>

<h5><a name="usingmessagelogginghandler"></a>Using MessageLoggingHandler</h5>
<p>Another method for logging SOAP messages is to add the <code>org.globus.wsrf.handlers.MessageLoggingHandler</code> to the request or response chain in the <code>server-config.wsdd</code> or <code>client-config.wsdd</code> files. </p>
<p>For example: </p>
<pre>&lt;requestFlow&gt;<br>  ...<br>  &lt;handler type="java:org.globus.wsrf.handlers.MessageLoggingHandler"/&gt;<br>  ...<br>&lt;requestFlow&gt;</pre>
<p>Then you must enable logging for this handler class in the appropriate <code>log4j.properties</code> files and change the logging level to DEBUG: </p>
<pre>log4j.category.org.globus.wsrf.handlers.MessageLoggingHandler=DEBUG</pre>

<h5><a name="enablinglogging"></a>Enabling logging for Axis classes</h5>
<p>Another method for tracing SOAP messages is to enable logging for selected
Axis classes. Add the following lines to the appropriate <code>log4j.properties</code> files: </p>
<pre>
 log4j.category.org.apache.client.Call=DEBUG
 log4j.category.org.apache.axis.transport.http.HTTPSender=DEBUG
 # enable the following logger for HTTPS/HTTPG transport handlers
 log4j.category.org.globus.axis.axis.transport=DEBUG
</pre>
<p>
This will log Axis client side calls and Axis HTTP messages.
</p>

<h4><a name="debugginglog4j"></a>Debugging Log4j</h4>

<p>If you are having problems with configuring Log4j, you can enable internal
  Log4j debugging by adding <code>-Dlog4j.debug=true</code> option on the <code>java</code> command
  line or passing it via the <code><a href="../Java_WS_Core_Public_Interfaces.html#GLOBUS_OPTIONS">GLOBUS_OPTIONS</a></code> environment
  property.</p>


<h2><a name="troubleshooting"></a>Troubleshooting</h2>
<ul>
  <li><a href="#nosocket">No socket factory for 'https' protocol</a></li>
  <li><a href="#general">General troubleshooting information </a> </li>
</ul>
<h3><a name="nosocket"></a>No socket factory for 'https' protocol</h3>
<p>
When a client fails with the following exception:
<pre>
 java.io.IOException: No socket factory for 'https' protocol
    at org.apache.axis.transport.http.HTTPSender.getSocket(HTTPSender.java:179)
    at org.apache.axis.transport.http.HTTPSender.writeToSocket(HTTPSender.java:397)
    at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:135)
</pre>
add the following to the client:
<pre>
 import org.globus.axis.util.Util;
 ...
 static {
     Util.registerTransport();
 }
 ...
</pre>
</p>

<?php
include_once( "./../Java_WS_Core_Troubleshooting_Frag.html" );
?>

<h2><a name="relateddocs"></a>Related Documentation</h2>
<p><font color="purple">[could link to pdfs and whitepapers about protocols, etc re: the component]</font></p>

<h2><a name="miscellaneousinfo"></a>Miscellaneous Information</h2>
<ul>
  <li><a href="#DocumentLiteral">Document/literal notes</a></li>
  <li> <a href="#OperationProvider">Operation provider details</a></li>
  <li><a href="#JNDIDetails">JNDI details</a> </li>
  <li><a href="#WritingClients">Client notes</a></li>
  <li><a href="#ContextProperties">MessageContext properties</a></li>
  <li><a href="#testing">Writing and running tests</a></li>
  <li><a href="#gardetails">GAR</a></li>
  <li><a href="#CreatingLaunchers">Generating launcher scripts</a></li>
  <li><a href="#ProxySupport">Proxy support</a></li>
  <li><a href="#Activation">Lifecycle and activation</a></li>
</ul>
<h3><a name="DocumentLiteral"></a>Document/literal notes</h3>

<p>
The WS-RF and WS-N specifications schemas follow the <b>document/literal</b> mode as described in <a href="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html">WS-I Basic Profile</a>. The Basic Profile defines certain rules to follow for document/literal and
other modes to ensure interoperability. 
</p>
<p>
For example, for document/literal mode, at most one &lt;wsdl:part&gt; is allowed in the &lt;wsdl:message&gt; element and it has to define the 'element' attribute. Also, the wire signatures must be unique (cannot use the same 'element' attribute in &lt;wsdl:part&gt; in two different &lt;wsdl:message&gt; elements). 
</p>
<p>
Java WS Core relies on these restrictions so please keep them in mind when designing your own schema. 
</p>
<p>
<strong>Note:</strong> Axis' WSDL2Java tool might sometimes incorrectly detect
that schema follows the wrapped/literal mode and generate wrong stub and type
classes. To ensure that document/literal mode is always used:
<ul>
  <li> use Java WS Core's <code>generateStub*</code> Ant tasks in <code>&lt;install&gt;/share/globus_wsrf_tools/build-stubs.xml</code> file</li>
  <li> if you are using Axis' WSDL2Java tool directly, you can alternatively specify the <code>-W</code> command line option.
  </li>
</ul>
<p>  
Also, with wrapped/literal mode, the element name had to match the operation
 name in wsdl. This is <strong>not</strong> necessary with document/literal mode.
</p>

<h3><a name="OperationProvider"></a>Operation provider details</h3>
<p>
GT3 introduced a concept of operation providers where a service could be composed
of different parts/classes. Java WS Core also supports this functionality. In GT3
operation providers had to implement a specific interface. In Java WS Core <strong>no</strong> such interface is required. As matter of fact an operation provider is not in any
way different from a standard web service. That means that <strong>any</strong> web service implementation can automatically be used as an operation provider (as long as it uses common or standard interfaces to operate on resources.)
</p>

<h4>Configuring operation providers</h4>

<p>To enable operation provider support for your service, make the following
  changes to the service deployment descriptor: </p>
<table border="1" cellpadding="5" cellspacing="0" width="100%" >
  <tr>
    <td valign="top">1</td>
    <td valign="top">Change the value of the <code>provider</code> attribute to <code>Handler</code>.</td>
  </tr>
  <tr>
    <td valign="top">2</td>
    <td valign="top">Add a <code>handleClass</code> parameter with a value of <code>org.globus.axis.providers.RPCProvider</code>.</td>
  </tr>
  <tr>
    <td valign="top">3</td>
    <td valign="top"><p>Specify providers in the <code>providers</code> parameter. </p>
      <p>The value
        of the parameter is a space-separated list of either provider names or
        class names. If provider names are used, they must  first be defined
        as  parameters in the <code>&lt;globalConfiguration&gt;</code> element
    of the <b>main</b> deployment descriptor (<code>etc\globus_wsrf_core\server-config.wsdd</code>). </p>
    <p>For example: </p>      <pre>
  &lt;globalConfiguration&gt;
  ...
   &lt;parameter name="GetRPProvider" 
              value="org.globus.wsrf.impl.properties.GetResourcePropertyProvider"/&gt;
  ...
  &lt;/globalConfiguration&gt;
</pre></td>
  </tr>
  <tr>
    <td valign="top">4</td>
    <td valign="top">Add or change the value of the <code>scope</code> parameter
      to <code>Application</code> or <code>Request</code></td>
  </tr>
</table>
<p>The following is an example of a modified service deployment descriptor:
  
</p>
<pre>
    &lt;service name="SubscriptionManagerService" <b>provider="Handler"</b>
        use="literal" style="document"&gt;
        &lt;parameter name="allowedMethods" value="*"/&gt;
        <b>&lt;parameter name="scope" value="Application"/&gt;</b>
        <b>&lt;parameter 
            name="providers"
            value="GetRPProvider 
                   org.globus.wsrf.impl.lifetime.SetTerminationTimeProvider
                   PauseSubscriptionProvider"/&gt;</b>
        <b>&lt;parameter 
            name="handlerClass" 
            value="org.globus.axis.providers.RPCProvider"/&gt;</b>
        &lt;parameter name="className" 
            value="org.globus.wsrf.impl.notification.ResumeSubscriptionProvider"/&gt;
        &lt;wsdlFile>share/schema/core/notification/subscription_manager_service.wsdl&lt;/wsdlFile&gt;
    &lt;/service&gt;
</pre>

<b>Note:</b> The operations defined in the <code>className</code> service always
overwrite the providers' operations. That is, if one provider defines the same
method as the service specified in the <code>className</code> parameter, the
operation will be invoked on the service. Also, if two providers define the same
method, the first one specified in the <code>providers</code> parameter will be invoked.


<h3><a name="JNDIDetails"></a>JNDI details</h3>
<p>
Java WS Core provides <a href="http://jakarta.apache.org/tomcat/tomcat-5.0-doc/jndi-resources-howto.html">Tomcat's JNDI</a> implementation. The file format of Java WS Core's <code>jndi-config.xml</code> is slightly different from the Tomcat's <code>server.xml</code> file. One main difference is that the <code>&lt;resourceParams&gt;</code> are specified as children of <code>&lt;resource&gt;</code> objects. Also, Java WS Core's <code>jndi-config.xml</code> parser is case sensitive and all elements names are lowercase. 
</p>
<p>All elements defined in the <code>&lt;global&gt;</code> section of the JNDI configuration file are deployed into the <code>java:comp/env</code> context under the name specified in the 'name' attribute. All <code>&lt;service&gt;</code> elements are deployed into <code>java:comp/env/&lt;service name&gt;</code> context. New objects and contexts can be added or modified dynamically at runtime but they will not be persisted. The only way to always have some object around is to deploy it in the <code>jndi-config.xml</code> file. All services <b>share</b> the same <code>java:comp/env</code> context. This is different from EJBs where each EJB has a separate <code>java:comp/env</code> context. 
</p>
<p>  
When deploying <code>&lt;resource&gt;</code> in <code>jndi-config.xml</code> make sure to use the <code>org.globus.wsrf.tools.jndi.BeanFactory</code> as a BeanFactory (value of a 'factory' parameter) instead of <code>org.apache.naming.factory.BeanFactory</code>. Your bean must have a default constructor. If your bean implements the <code>org.globus.wsrf.tools.jndi.Initializable</code> interface, the <code>initialize()</code> function will be automatically called after all parameters are set on the bean. 
</p>
<p> 
Please see <a href="http://java.sun.com/products/jndi/tutorial/">The JNDI Tutorial</a> for more information on JNDI programming. 
</p>

<h3><a name="WritingClients"></a>Client notes</h3>
<p>
Any program that is based on Java WS Core should contain as a first entry in its classpath the directory of the Java WS Core installation. This is to ensure that the right <code>client-config.wsdd</code> is used by the client. That configuration file contains important client-side information such as handlers, type mappings, etc.
</p>
<p>
Also, any program that is a notification consumer should be initialized with the appropriate <code>GLOBUS_LOCATION</code> system property (set to the installation directory of Java WS Core). If the system property is not set the notification consumer might not initialize or work properly.
</p>

<h3><a name="ContextProperties"></a>MessageContext properties</h3>

The following properties can be obtained from the SOAPContext/MessageContext associated with the current thread:

<ul>
<li>
<b><code>org.apache.axis.Constants.MC_HOME_DIR</code></b> - the base directory from which the wsdl files are loaded from. 
</li>
<li>
<b><code>org.apache.axis.Constants.MC_CONFIGPATH</code></b> - the base directory from which different configuration files are loaded from. 
</li>
<li>
<b><code>org.apache.axis.Constants.MC_REMOTE_ADDR</code></b> - contains the IP address of the client
</li>
<li>
<b><code>org.apache.axis.MessageContext.TRANS_URL</code></b> - the URL of the request
</li>
</ul>

<p>
The <code>Constants.MC_CONFIGPATH</code> property should be used to load any type of configuration files. Only <code>Constants.MC_CONFIGPATH</code> and <code>Constants.MC_HOME_DIR</code> are associated with thread during activation.
<br>
In the standalone container the <code>Constants.MC_HOME_DIR</code> and <code>Constants.MC_CONFIGPATH</code> properties will usually point to the same directory. However, in Tomcat they will point to two different directories.
</p>

<h3><a name="testing"></a>Writing and running tests</h3>
<p>Tests in the Java WS Core are based on the <a href="http://www.junit.org/">JUnit</a> API. JUnit must first be installed with Ant. To install JUnit with Ant copy the <code>junit.jar</code> found in JUnit distribution to the <code>$ANT_HOME/lib</code> directory.
</p>

<h4><a name="writingtests">Writing Tests</a></h4>
<p>
Always make sure to group your tests under <code>PackageTests.java</code> and/or <code>SecurityTests.java</code> test
suites. Put all tests that require any type of credentials in the <code>SecurityTests.java</code> test
suite. 
</p>

<p>
If you are writing  basic unit tests that do not require a container to run,
just use the regular JUnit classes to write such tests. </p>
<p>If you are writing
    tests that require a container to execute, use the <code>org.globus.wsrf.test.GridTestCase</code> class
    instead of <code>junit.framework.TestCase</code> as your base class for your
    tests. Also ensure your <code>PackageTests.java</code> or <code>SecurityTests.java</code> extends
    the <code>org.globus.wsrf.test.GridTestSuite</code> instead of <code>junit.framework.TestSuite</code>. </p>
The <code>org.globus.wsrf.test.GridTestSuite</code> and <code>org.globus.wsrf.test.GridTestCase</code> <strong>must</strong> be
used together. The <code>org.globus.wsrf.test.GridTestCase</code> class exposes
a <code>TEST_CONTAINER</code> variable that can be used to obtain the URL of
the container (<code>TEST_CONTAINER.getBaseURL()</code>). By default an embedded
container will be started for all tests in the test suite. To specify an external
container, pass <code>-Dweb.server.url=&lt;base.url&gt;</code> system property
on the <code>java</code> command line.

<h4><a name="runningtests">Running Tests</a></h4>
<p>
To execute the tests on the Java WS Core install, run the following (assuming
  the tests have been deployed into that install):

<pre>
$ cd $GLOBUS_LOCATION
$ ant -f share/globus_wsrf_test/runtests.xml runServer -Dtests.jar=&lt;test.jar&gt;
</pre>

<p>Where <code>&lt;test.jar&gt;</code> is an <b>absolute</b> path to the jar file that contains the tests. </p>
<p>By default, the tests that use a container will try to access a container
running at <code>http://localhost:8080/wsrf/services/</code>. </p>
<p>To specify a
    different container, use the <code>-Dtest.server.url=&lt;url&gt;</code> property.
</p>
<p>To execute PackageTests only, specify <code>-DbasicTestsOnly=true</code>.
</p>
<p>To execute SecurityTests only, specify <code>-DsecurityTestsOnly=true</code>. </p>
<p>  The test reports will be put in <code>$GLOBUS_LOCATION/share/globus_wsrf_test/test-reports</code> directory
            by default. The different test reports directory can be specified
    by passing <code>-Djunit.reports.dir=&lt;directory&gt;</code>.
</p>
            
<h3><a name="gardetails"></a>GAR</h3>
<p>
The GAR (Grid Archive) file is a single file which contains all the files and information that the container needs to deploy a service. The GAR files are deployed using <a href="../Java_WS_Core_Public_Interfaces.html#deployGar">deployGar</a> and undeployed using <a href="../Java_WS_Core_Public_Interfaces.html#undeployGar">undeployGar</a> Ant tasks.

<h4>GAR file structure</h4>
<dl>
  <dt><code>docs/</code></dt>
  <dd>This directory contains service documentation files. </dd>
  <dt><code>share/</code></dt>
  <dd>This directory contains files that can be accessed or used by all services. </dd>
  <dt><code>schema/</code></dt>
  <dd>This directory contains service WSDL and schema files. </dd>
  <dt><code>etc/</code></dt>
  <dd>This directory contains service configuration files and a <code>post-deploy.xml</code> Ant script. </dd>
  <dt><code>bin/</code></dt>
  <dd>This directory contains service executables such as command line tools, GUI, etc. </dd>
  <dt><code>lib/</code></dt>
  <dd>This directory contains service and third party library files and any LICENSE files. </dd>
  <dt><code>server-deploy.wsdd</code></dt>
  <dd>This file is the server side deployment descriptor. </dd>
  <dt><code>client-deploy.wsdd</code></dt>
  <dd>This file is the client side deployment descriptor. </dd>
  <dt><code>jndi-config-deploy.xml</code></dt>
  <dd>This file is the JNDI configuration file. </dd>
</dl>
<h4>Creating a GAR file through Ant</h4>

<h5>Creating GAR file</h5>
<p>
To create a GAR file use the following (for example):
</p>
<pre>
 &lt;property name="build.packages" location=
      "${deploy.dir}/share/globus_wsrf_common/build-packages.xml"/&gt;
 ...
 &lt;property name="garjars.id" value="garjars"/&gt;
 &lt;fileset dir="lib" id="garjars"/&gt;

 &lt;property name="garetc.id" value="garetc"/&gt;
 &lt;fileset dir="etc" id="garetc"/&gt;
 ...
 &lt;target name="dist" depends="..."&gt;
   &lt;ant antfile="${build.packages}" target="makeGar"&gt;
     &lt;property name="gar.name" value="mygar.gar"/&gt;
     &lt;reference refid="${garjars.id}"/&gt;
     &lt;reference refid="${garetc.id}"/&gt;
   &lt;/ant>            
 &lt;/target>
</pre>
<p>
The <code>gar.name</code> property must be passed. That property specifies the gar file to create. The <code>makeGar</code> task will look for <code>deploy-client.wsdd</code>, <code>deploy-server.wsdd</code>, and <code>deploy-jndi-config.xml</code> files in the base directory of the calling Ant process. All of these files are optional and do not have exist. The list of files to be included in the GAR file is passed via Ant references. The <code>makeGar</code> accpets the following references: <code>garjars.id</code>, <code>garschema.id</code>, <code>garetc.id</code>, <code>garshare.id</code>, <code>gardocs.id</code>, and <code>garbin.id</code>. All of these references are optional and do not have to be defined.</p>
<p>
In the above example, all files in the <code>etc</code> and <code>lib</code> directories, and <code>deploy-client.wsdd</code>, <code>deploy-server.wsdd</code>, <code>deploy-jndi-config.xml</code> files (if they exist) will be included into the GAR file.
</p>

<h5>Deploying GAR file</h5>
<p>
To deploy a GAR file use the following (for example):
</p>
<pre>
 &lt;property name="build.packages" location=
      "${deploy.dir}/share/globus_wsrf_common/build-packages.xml"/&gt;
 ...
 &lt;target name="deploy" depends="..."&gt;
   &lt;ant antfile="${build.packages}" target="deployGar"&gt;
     &lt;property name="gar.name" value="mygar.gar"/&gt;
   &lt;/ant&gt;
 &lt;/target&gt;
</pre>
<p>
The <code>gar.name</code> property must be passed. That property specifies the gar file to deploy. Optionally, <code>profile</code> property can be passed to indicate which configuration profile the gar should be deployed under.
</p>

<h5>Undeploying GAR file</h5>
<p>
To undeploy a GAR file use the following (for example):
</p>
<pre>
 &lt;property name="build.packages" location=
      "${deploy.dir}/share/globus_wsrf_common/build-packages.xml"/&gt;
 ...
 &lt;target name="undeploy"&gt;
   &lt;ant antfile="${build.packages}" target="undeployGar"&gt;
     &lt;property name="gar.id" value="mygar"/&gt;
   &lt;/ant&gt;
 &lt;/target&gt;
</pre>
<p>
The <code>gar.id</code> property must be passed. That property specifies the base name of the gar to undeploy.
</p>

<h4><a name="gardeploy">GAR file deployment</a></h4>

<p>The contents of the GAR file are processed in the following way (all steps
  are performed only if necessary):</p>
<ul>
 <li>
  Any files in the <code>docs/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/docs/&lt;gar.id&gt;/</code> directory.
 </li>
 <li>
  Any files in the <code>share/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/share/&lt;gar.id&gt;/</code> directory.
 </li>
 <li>
  Any files in the <code>schema/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/share/schema/</code> directory.
 </li>
 <li>
  Any files in the <code>etc/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/</code> directory.
 </li>
 <li>
  Any files in the <code>bin/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/bin/</code> directory.
 </li>
 <li>
  Any <code>.jar</code> files in the <code>lib/</code> directory of the GAR are
  copied into <code>$GLOBUS_LOCATION/lib/</code> directory.
 </li>
 <li>
  Any file that contains the word "LICENSE" in the name in the <code>lib/</code> directory
  of the GAR is copied into <code>$GLOBUS_LOCATION/share/licenses/</code> directory.
 </li>
 <li>
  The <code>server-deploy.wsdd</code> in the GAR is copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/server-config.wsdd</code>.
  If a profile name was specified during deployment, the <code>server-deploy.wsdd</code> will
  be copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-server-config.wsdd</code>.
  The <code>server-config.wsdd</code> file will be set with user-only access
  permissions.
 </li>
 <li>
  The <code>jndi-config-deploy.xml</code> in the GAR is copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/jndi-config.xml</code>.
  If a profile name was specified during deployment the <code>jndi-config-deploy.xml</code> will
  be copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-jndi-config.xml</code>.
  The <code>jndi-config.xml</code> file will be set with user only-access permissions.
 </li>
 <li>
  The <code>client-deploy.wsdd</code> in the GAR is merged into a common <code>$GLOBUS_LOCATION/client-config.wsdd</code> file.
 </li>
 <li>
  An undeploy script (<code>$GLOBUS_LOCATION/etc/globus_packages/&lt;gar.id&gt;/undeploy.xml</code>) is created.
 </li>
 <li>
  A <code>etc/post-deploy.xml</code> Ant script is called if the GAR contains
  one. The <i>setup</i> target is called automatically.
 </li>

</ul>

<p>Notes:</p>
<ul>
  <li>If <code>post-deploy.xml</code> script creates some files, they will <strong>not</strong> be removed by
    <code>undeploy</code>. </li>
  <li>During deployment, filtering is done for contents of <code>server-deploy.wsdd</code> and <code>jndi-config-deploy.xml</code> files
      to replace the <code>@config.dir@</code> token
      with the "<code>etc/&lt;gar.id&gt;</code>" value, and the <code>@gar.id@</code> token
    with the "<code>&lt;gar.id&gt;</code>" value. </li>
</ul>

<h3><a name="CreatingLaunchers"></a>Generating launcher scripts</h3>
<p>
Bourne Shell and Windows batch scripts can be automatically generated to hide the details of launching a Java program from the command line. 
<br>
To generate such a command line script write a Ant task that calls <code>generateLauncher</code> target in <code>$GLOBUS_LOCATION/share/globus_wsrf_common/build-launcher.xml</code>. The following properties/parameters must be specified:
</p>
<ul>
  <li><b><code>${launcher-name}</code></b> - the base name of script to generate</li>
  <li><b><code>${class.name}</code></b> - the name of Java class the script must call.</li>
</ul>
<p>
For example:
</p>
<pre>   ...
   &lt;property name="env.GLOBUS_LOCATION" value="."/&gt;
   &lt;property name="deploy.dir" location="${env.GLOBUS_LOCATION}"/&gt;
   &lt;property name="abs.deploy.dir" location="${deploy.dir}"/&gt;
   &lt;property name="build.launcher"
        location="${abs.deploy.dir}/share/globus_wsrf_common/build-launcher.xml"&gt;
   ...
   &lt;ant antfile="${build.launcher}" target="generateLauncher"&gt;
        &lt;property name="launcher-name" value="myClient"/&gt;
        &lt;property name="class.name" value="org.mypackage.MyClient"/&gt;
   &lt;/ant&gt;
</pre>
<p>
It is also possible to specify defaults JVM options and command-line
via the <code>default.jvm.options</code> and <code>default.cmd.line</code> parameters.<br>
In general the generation of the command line scripts is done in <code>post-deploy.xml</code> script during <a href="#gardeploy">GAR deployment</a>.
</p>


<h3><a name="ProxySupport">Proxy support</a></h3>

<p>
A basic proxy support is provided. A <b><code>org.globus.wsrf.proxy.port</code></b> system property can be set to the port of the proxy server (the proxy server must run on the same machine as the container). This will make any code that uses <code>ServiceHost</code> or <code>AddressingUtils</code> API return the address of the proxy server instead of the container. This could be useful for example for debugging purposes.<br>
The <b><code>org.globus.wsrf.proxy.port</code></b> system property can be passed to <code>globus-start-container</code> script via <code>GLOBUS_OPTIONS</code> environment property. For example:
</p>
<pre>
 setenv GLOBUS_OPTIONS="-Dorg.globus.wsrf.proxy.port=5555"
 globus-start-container
</pre>
<p>
Please note that not all of the core code will obey the proxy port setting.
</p>

<h3><a name="Activation">Lifecycle and activation</a></h3>

<h4>Service</h4>

<h5>Axis RPCProvider</h5>

<p>
The <code>scope</code> setting of the service dictates when and how service instances are created. If the <code>scope</code> setting is set to <i>Application</i>, one instance of the service is used for all invocations. If the <code>scope</code> setting is set to <i>Request</i>, one instance is created per invocation. If the <code>scope</code> setting is set to <i>Session</i>, one instance is created per session. The <i>Request</i> scope is default (if scope parameter is not set in the deployment descriptor). If service implements the <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/rpc/server/ServiceLifecycle.html">javax.xml.rpc.server.ServiceLifecycle</a> interface the lifecycle methods they will be called accordingly to the scope setting as a service instance is created and destroyed. For example, in <i>Application</i> scope <i>destroy()</i> will be called on container shutdown, and in <i>Request</i> scope it will be called after the service method is called. <br>
With Axis RPCProvider JAAS credentials are never associated with the invocation thread.
</p>

<h5>Globus RPCProvider</h5>

<p>
Only <i>Application</i> and <i>Request</i> scopes are supported with Globus RPCProvider. If <i>Request</i> scope it behaves more or less just like the Axis RPCProvider (service/providers instances are created per invocation, ServiceLifecycle methods called right before and after service method invocation, no JAAS credentials during ServiceLifecycle methods). <br>
If <i>Application</i> scope service/provider instances are created either on first invocation or on container startup if the <i>"loadOnStartup"</i> parameter in the deployment descriptor is set to <i>"true"</i>. This will work in the same way in the standalone container and in Tomcat. <br>
If the service or the container is configured with a security descriptor, the appropriate credentials will be associated with the thread during activation (using JAAS). Also, during activation a basic Axis MessageContext will be associated with the thread with only <i>Constants.MC_HOME_DIR</i>, <i>Constants.MC_CONFIGPATH</i>, and the right target service properties set (see <a href="#ContextProperties">MessageContext Properties</a> section for details). If service or providers implement the <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/rpc/server/ServiceLifecycle.html">javax.xml.rpc.server.ServiceLifecycle</a> interface the lifecycle methods will be called accordingly.
</p>

<h4>ResourceHome</h4>

<p>
ResourceHome will be activated on the first service invocation or during container startup if <i>"loadOnStartup"</i> parameter is set to <i>"true"</i>. If ResourceHome get activated in such ways, proper MessageContext and/or JAAS subject will be associated with the thread. Also proper MessageContext and/or JAAS subject will be associated with the thread if the ResourceHome gets activated by a separate thread directly looking up the ResourceHome implementation in JNDI. This actually applies to all <i>resource</i> entries directly defined under <i>service</i> entries in <i>jndi-config.xml</i> and configured with <i>org.globus.wsrf.jndi.BeanFactory</i> factory.
</p>

<h5>ServiceResourceHome</h5>

<p>
If you are using ServiceResourceHome please make sure to deploy the service with <i>"loadOnStartup"</i> option enabled and in <i>Application</i> scope. That will ensure that the ResourceHome is initialized with the right service/resource.
</p>


<?php include("/mcs/www-unix.globus.org/include/globus_footer_dev_docs.inc"); ?>
