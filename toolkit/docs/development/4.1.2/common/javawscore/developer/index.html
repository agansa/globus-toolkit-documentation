<?php 
$title="GT 4.0 Java WS Core : Developer's Guide ";
include_once( "/mcs/www-unix.globus.org/include/globus_header.inc" ); ?>

<?php
include_once( "http://www-unix.globus.org/toolkit/docs/development/4.0-drafts/draft.inc" );
?>

<h1><?php echo $title; ?></h1>
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#archdes">Architecture and design overview</a></li>
  <li><a href="#pubinterfaces">Public interface</a></li>
  <li><a href="#scenarios">Usage scenarios</a> 
   <ul>
    <li><a href="#NotificationConsumer">Notification Consumer</a></li>
    <li><a href="#EndpointInfo">Container Endpoint Information</a></li>
    <li><a href="#LocalInvocations">Local Invocations</a></li>
    <li><a href="#CustomExpressionEval">Custom Query/Topic Expression Evaluators</li>
    <li><a href="#GetCurrentMessageProvider">Notification Message Types and GetCurrentMessageProvider</li>
   </ul>
  </li>
  <li><a href="#tutorials">Tutorials</a></li>
  <li><a href="#features">Feature summary</a></li>
  <li><a href="#platforms">Tested platforms</a></li>
  <li><a href="#compatibility">Backward compatibility summary</a></li>
  <li><a href="#dependencies">Technology dependencies</a></li>
  <li><a href="#security_considerations">Security considerations</a> </li>
  <li><a href="#troubleshooting">Troubleshooting</a></li>
  <li><a href="#relateddocs">Related Documentation</a></li>
  <li><a href="#miscellaneousinfo">Miscellaneous information</a>
   <ul>
    <li><a href="#ContextProperties">MessageContext Properties</a></li>
    <li><a href="#debugging">Debugging and Logging</a></li>
    <li><a href="#testing">Writing and Running Tests</li>
    <li><a href="#gardetails">GAR</li>
    <li><a href="#CreatingLaunchers">Generating Launcher Scripts</li>
   </ul>
  </li>
</ul>
<h2><a name="introduction"></a>Introduction</h2>
<p><font color="purple">[introduction to developers with reference to General Toolkit Developer's Guide for
  coding guidelines, porting guide, etc.]</font></p>
<h2><a name="archdes"></a>Architecture and design overview</h2>

<ul>
  <li>Java WS Core Design Document [<a href="JavaWSCoreDesign.doc">doc</a> | pdf ]</li>
  <li>Java WS Core UML [<a href="JavaWSCoreUML.vsd">vsd</a>]</li>
</ul>

<h2><a name="pubinterfaces"></a>Public interface</h2>
<p>The semantics and syntax of the APIs and WSDL for the component, along with
  descriptions of domain-specific structured interface data, can be found in
  the <a href="../Java_WS_Core_Public_Interfaces.html">public interface guide</a>.</p>
<h2><a name="scenarios"></a>Usage scenarios</h2>


<h3><a name="NotificationConsumer">Notification Consumer</a></h3>
<p>
There are a few steps involved in setting up and receiving notifications:
<ul>
 <li>Callback implementation</li>
 <li>NotificationConsumerManager</li>
 <li>Registration of callback</li>
 <li>Subscription</li>
 <li>Clean up</li>
</ul>
</p>

<h4>Callback implementation</h4>
<p>
The notification consumer application must provide an implementation of the <code>org.globus.wsrf.NotifyCallback</code> interface. The <code>deliver</code> function of the interface will be invoked whenever a notification for that consumer arrives. The <code>message</code> parameter will either be of <code>org.w3c.dom.Element</code> type if the message type was unknown or some object mapped to the type of the message. <br>
Please note that the <code>deliver</code> function should be thread-safe as multiple notifications might come at once. Notifications might also come unordered and some might even be lost.
</p>

<h4>NotificationConsumerManager</h4>
<p>
In order to facilitate the receipt of notifications a <code>NotificationConsumerManager</code> needs to be started. The <code>NotificationConsumerManager</code> starts an embedded container through which the notifications are handled. To start a <code>NotificationConsumerManager</code> do:
</p>
<pre>
 import org.globus.wsrf.NotificationConsumerManager; 
 ...

 NotificationConsumerManager consumer = null;
 try {
    consumer = NotificationConsumerManager.getInstance();
    consumer.startListening();
    ...
</pre>

<h4>Registration of callback</h4>
<p>
The callback implementation needs to be registered with the <code>NotificationConsumerManager</code> (once it is started) using the <code>createNotificationConsumer</code> function. The <code>createNotificationConsumer</code> function returns an endpoint for this notification consumer. Example:
</p>
<pre>
 import org.globus.wsrf.NotifyCallback;
 import org.apache.axis.message.addressing.EndpointReferenceType;
 ...

    MyCallback callback = new MyCallback();
    EndpointReferenceType consumerEPR =
        consumer.createNotificationConsumer(callback);
    ...

 class MyCallback implements NotifyCallback {
   ....
 }
</pre>

<h4>Subscription</h4>
<p>
The endpoint returned by the <code>createNotificationConsumer</code> function can be then passed to the subscribe call. Example:
</p>
<pre>
 import org.oasis.wsn.TopicExpressionType;
 import org.oasis.wsn.Subscribe;
 import org.oasis.wsn.SubscribeResponse;
 import org.globus.wsrf.WSNConstants;
 import org.globus.wsrf.WSRFConstants;
 ...

    TopicExpressionType topicExpression = new TopicExpressionType();
    topicExpression.setDialect(WSNConstants.SIMPLE_TOPIC_DIALECT);
    topicExpression.setValue(WSRFConstants.TERMINATION_TIME);

    Subscribe request = new Subscribe();
    request.setUseNotify(Boolean.TRUE);
    request.setConsumerReference(consumerEPR);
    request.setTopicExpression(topicExpression);

    SubscribeResponse subResponse = port.subscribe(request);
    ...
</pre>

<h4>Clean up</h4>
<p>
Once done with the notifications make sure to explicitly destroy the subscription resource or set its termination time. <br>
For example:
</p>
<pre>
 import org.globus.wsrf.core.notification.SubscriptionManager;
 import org.globus.wsrf.core.notification.service.SubscriptionManagerServiceAddressingLocator;
 import org.oasis.wsrf.lifetime.Destroy;
 ...

    SubscriptionManagerServiceAddressingLocator sLocator =
        new SubscriptionManagerServiceAddressingLocator();
    SubscriptionManager manager = sLocator.getSubscriptionManagerPort(
                        subResponse.getSubscriptionReference());
    manager.destroy(new Destroy());
    ...
</pre>


<p>
Also, please ensure to call (especially in error cases) <b><code>NotificationConsumerManager.removeNotificationConsumer()</code></b> function to unregister the callbakc from the <code>NotificationConsumerManager</code>. In addition make sure to always call the <b><code>NotificationConsumerManager.stopListening()</code></b> function when finished using the <code>NotificationConsumerManager</code>. Otherwise, some resources might not be released. <br>
For example:
</p>
<pre>
    ...
 } catch(Exception e) {
    ...
 } finally {
    if (consumer != null) {
       try { consumer.stopListening(); } catch (Exception ee) {}
    }
 }
</pre>

<h3><a name="EndpointInfo">Container Endpoint Information</a></h3>
<p>
In most cases, a service will need to return an endpoint information of the container to a client. Unfortunately, getting that information might not be easy. The only reliable way of getting the container endpoint information is to extract it from the <code>MessageContext.TRANS_URL</code> property of the <code>MessageContext/ResourceContext</code> associated with the current thread. We provide <code>ServiceHost</code> API to obtain that information easily, for example:
</p>
<pre>
 import org.globus.wsrf.container.ServiceHost;
 ...
 URL containerBaseUrl = ServiceHost.getBaseURL();
 ...
</pre>
<p>
The above will return the base container URL such as <code>http://localhost:8080/wsrf/services/</code>.
</p>
We also provide convenience API for creating WS-Addressing endpoints, for example:</p>
<pre>
 import org.apache.axis.message.addressing.EndpointReferenceType;
 import org.globus.wsrf.utils.AddressingUtils;
 ...
 EndpointReferenceType containerEndpoint = 
        AddressingUtils.createEndpointReference(null);
 ...
</pre>
<p>
The above will return the <code>EndpointReferenceType</code> object with the <code>Address</code> field set to the base container URL (as before) and empty reference properties.
</p>
<p>
<b>Note:</b> The <code>ServiceHost</code> API will return the correct information and <code>AddressingUtils</code> API will work correctly, only if called from the same thread as the service method was invoked from.
</p>

<h3><a name="LocalInvocations">Local Invocations</a></h3>

<p>
Services in the container can be invoked locally. Local invocations work just like remote invocations (all handlers are called, messages get serialized/deserialized) but messages do not travel over the network - everything happens in memory. 
</p>
<p>
Local invocations can only be made on the server side and only when a Axis MessageContext is associated with a current thread. URLs with "<i>local</i>" protocol name are used for local invocations. To invoke a service locally do:

<table cellpadding="5">

<tr>
<td valign="top">1</td>
<td valign="top">
<p>Register "<i>local</i>" protocol handler:</p>
<pre>
import org.globus.axis.transport.local.LocalTransportUtils;
...
<b>LocalTransportUtils.init();</b>
...
</pre>
</td>
</tr>

<tr>
<td valign="top">2</td>
<td valign="top">
<p>Create a service URL with "<i>local</i>" protocol:</p>
<pre>
URL url = new URL(<b>"local:///wsrf/services/MyService"</b>);
</pre>
</td>
</tr>

<tr>
<td valign="top">3</td>
<td valign="top">
<p>Configure the service stub for local invocation and make the call:</p>
<pre>
MyServiceAddressingLocator locator = 
       new MyServiceAddressingLocator();
MyService port = locator.getMyServicePort(url);

<b>LocalTransportUtils.enableLocalTransport((Stub)port);</b>

port.hello();
</pre>
</table>
</p>
<h3><a name="CustomExpressionEval">Custom Query/Topic Expression Evaluators</a></h3>
<p>
Java WS Core allows for custom query/topic expression evaluators to be plugged in. The process of adding a new query/topic expression evaluator is composed of three steps:
<ul>
 <li>Implementation of the evaluator</li>
 <li>Registration of the evaluator</li>
 <li>Registration of the serializer/deserializer for the evaluator</li>
</ul>
</p>

<h4>Implementation</h4>
<p>
The query expression evaluators must implement the <code>org.globus.wsrf.query.ExpressionEvaluator</code> while the topic expression evaluators must implement the <code>org.globus.wsrf.topicexpression.TopicExpressionEvaluator</code> interface.
</p>

<h4>Registration</h4>
<p>
The evaluators must be registered in order for Java WS Core to recognize them. The registration is done through the JNDI configuration file. The expression evaluators must be deployed as global resources under a specific subcontext. The query expression evaluators they must be put under <b><code>query/eval/</code></b> subcontext while the topic expression evaluators must be put under <b><code>topic/eval/</code></b> subcontext. 
</p>
<p>
Example of query expression evaluator registration:
</p>
<pre>
 &lt;global&gt;
  &lt;resource name="query/eval/<b>MyQueryExpressionEval</b>"
            type="<b>foo.bar.MyQueryExpressionEvaluator</b>">
    &lt;resourceParams&gt;
     &lt;parameter&gt;
      &lt;name&gt;factory&lt;/name&gt;
      &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
     &lt;/parameter&gt;
    &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</pre>
<p>
Example of topic expression evaluator registration:
</p>
<pre>
 &lt;global&gt;
  &lt;resource name="topic/eval/<b>MyTopicExpressionEval</b>"
            type="<b>foo.bar.MyTopicExpressionEvaluator</b>">
    &lt;resourceParams&gt;
     &lt;parameter&gt;
      &lt;name&gt;factory&lt;/name&gt;
      &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
     &lt;/parameter&gt;
    &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</pre>
<p>
Please note that the <b><code>type</code></b> attribute specifies the class that implements the expression evaluator. The <b><code>name</code></b> attribute specifies the name of the evaluator in JNDI space. The name can be arbitrary as long as it is unique and is in the right subcontext as explained above.
</p>
<h4>Registration serializers/deserializers</h4>
<p>
A serializer/deserializer must be registered for the dialect of the evaluator in order for the expression to be properly serialized and deserialized. The serializers/deserializers for the dialect are deployed as almost any other type mapping. In general each type mapping specifies a type QName. For dialect serializers/deserializers that type QName takes a slightly different name.<br>
In case of query expression evaluator that QName must have the local name part set to <b><code>QueryExpressionDialect</code></b> and namespace part set to the dialect of the query expression evaluator. For example:
</p>
<pre>
 &lt;typeMapping 
    encodingStyle="" 
    deserializer="org.apache.axis.encoding.ser.SimpleDeserializerFactory"
    serializer="org.apache.axis.encoding.ser.SimpleSerializerFactory"
    type="java:java.lang.String"
    qname="ns12:QueryExpressionDialect" 
    xmlns:ns12="http://foo.bar/MyQueryDialect"/&gt;
</pre>
<p>
Similarly, in case of topic expression evaluator that QName must have the local name part set to <b><code>TopicExpressionDialect</code></b> and namespace part set to the dialect of the topic expression evaluator. For example:
</p>
<pre>
 &lt;typeMapping 
    encodingStyle="" 
    deserializer="org.apache.axis.encoding.ser.SimpleDeserializerFactory"
    serializer="org.apache.axis.encoding.ser.SimpleSerializerFactory"
    type="java:java.lang.String"
    qname="ns12:TopicExpressionDialect" 
    xmlns:ns12="http://foo.bar/MyTopicDialect"/&gt;
</pre>
<p>
Please note that these type mappings must be deployed both on the client and the server. 
</p>


<h3><a name="GetCurrentMessageProvider">Notification Message Types and GetCurrentMessageProvider</a></h3>
<p>
The standard <code>GetCurrentMessageProvider</code> might not know how to property serialize the notification message currently associated with the specified topic. The <code>GetCurrentMessageProvider</code> can be configured use a helper serializer for a given notification message type. To configure such helper serializer define the following global resource in your <code>deploy-jndi.xml</code> configuration file:
</p>
<pre>
 &lt;global&gt;
   &lt;resource
    name="providers/GetCurrentMessageProvider/<b>foo.bar.MyNotificaionMessage</b>"
    type="<b>foo.bar.MyMessageSerializer</b>"&gt;
      &lt;resourceParams&gt;
        &lt;parameter&gt;
          &lt;name&gt;factory&lt;/name&gt;
          &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
        &lt;/parameter&gt;
      &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</pre>
<p>
The <code>type</code> attribute specifies the class that implements the <code>org.globus.wsrf.encoding.ObjectConverter</code> interface and is responsible for serializing the notification message. The <code>name</code> attribute must start with <b><code>providers/GetCurrentMessageProvider/</code></b> and must end with the full class name of the notification message. The <code>GetCurrentMessageProvider</code> will use the type of the notification message to find the helper serializer.
</p>

<h2><a name="tutorials"></a>Tutorials</h2>
<p><font color="purple">[add links to any tutorials - if no tutorials, say &quot;There
    are no tutorials available at this time&quot;] </font></p>
<h2><a name="features"></a>Feature summary</h2>
<?php
include_once( "./../Java_WS_Core_Feature_Summary_Frag.html" );
?>
<h2><a name="platforms"></a>Tested platforms</h2>
<?php
include_once( "../Java_WS_Core_Platform_Summary_Frag.html" );
?>
<h2><a name="compatibility"></a>Backward compatibility summary</h2>
<?php
include_once( "./../Java_WS_Core_Compatibility_Summary_Frag.html" );
?>
<h2><a name="dependencies"></a>Technology dependencies</h2>
<?php
include_once( "./../Java_WS_Core_Dependencies_Summary_Frag.html" );
?>
<h2><a name="security_considerations"></a>Security Considerations </h2>
<p>
  <?php
include_once( "./../Java_WS_Core_Security_Considerations_Frag.html" );
?>
</p>
<h2><a name="troubleshooting"></a>Troubleshooting</h2>

<h3>No socket factory for 'https' protocol</h3>
<p>
When a client fails with the following exception:
<pre>
 java.io.IOException: No socket factory for 'https' protocol
    at org.apache.axis.transport.http.HTTPSender.getSocket(HTTPSender.java:179)
    at org.apache.axis.transport.http.HTTPSender.writeToSocket(HTTPSender.java:397)
    at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:135)
</pre>
add the following to the client:
<pre>
 import org.globus.axis.util.Util;
 ...
 static {
     Util.registerTransport();
 }
 ...
</pre>
</p>

<?php
include_once( "./../Java_WS_Core_Troubleshooting_Frag.html" );
?>

<h2><a name="relateddocs"></a>Related Documentation</h2>
<p><font color="purple">[could link to pdfs and whitepapers about protocols, etc re: the component]</font></p>

<h2><a name="miscellaneousinfo"></a>Miscellaneous information</h2>

<h3><a name="ContextProperties">MessageContext Properties</a></h3>

The following properties can be obtained from the SOAPContext/MessageContext associated with the current thread:

<ul>
<li>
<b><code>org.apache.axis.Constants.MC_HOME_DIR</code></b> - the base directory from which the wsdl files are loaded from. 
</li>
<li>
<b><code>org.apache.axis.Constants.MC_CONFIGPATH</code></b> - the base directory from which different configuration files are loaded from. 
</li>
<li>
<b><code>org.apache.axis.Constants.MC_REMOTE_ADDR</code></b> - contains the IP address of the client
</li>
<li>
<b><code>org.apache.axis.MessageContext.TRANS_URL</code></b> - the URL of the request
</li>
</ul>

<p>
The <code>Constants.MC_CONFIGPATH</code> property should be used to load any type of configuration files. Only <code>Constants.MC_CONFIGPATH</code> and <code>Constants.MC_HOME_DIR</code> are associated with thread during activation.
<br>
In the standalone container the <code>Constants.MC_HOME_DIR</code> and <code>Constants.MC_CONFIGPATH</code> properties will usually point to the same directory. However, in Tomcat they will point to two different directories.
</p>

<h3><a name="debugging">Debugging and Logging</a></h3>

<p>Logging in the Java WS Core is based on the <a href="http://jakarta.apache.org/commons/logging/">Jakarta Commons Logging</a> API. Commons Logging provides a consistent interface for instrumenting source code while at the same time allowing the user to plug-in a different logging implementation. Currently we use <a href="http://logging.apache.org/log4j/">Log4j</a> as a logging implementation. Log4j uses a separate configuration file to configure itself. Please see Log4j documentation for details on the <a href="http://logging.apache.org/log4j/docs/api/org/apache/log4j/PropertyConfigurator.html#doConfigure(java.lang.String, org.apache.log4j.spi.LoggerRepository)">configuration file format</a>.
</p>
<p>
Java WS Core is deployed with two Log4j configuration files:</p>
<ul>
 <li>
   <code>$GLOBUS_LOCATION/container-log4j.properties</code> (configures logging
   for the standalone container)</li>
 <li>
   <code>$GLOBUS_LOCATION/log4j.properties</code> (configures logging for everything
   else besides the standalone container)</li>
</ul>


<h4><a name="tracingsoapmessages"></a>Tracing SOAP messages</h4>

<p>There are three methods for tracing SOAP messages: </p>
 <ul>
   <li><a href="#usingtcpmon">Using TcpMonitor</a>
   <li><a href="#usingmessagelogginghandler">Using MessageLoggingHandler</a>
   <li><a href="#enablinglogging">Enabling logging for Axis classes</a>. 
 </ul>


<h5><a name="usingtcpmon"></a>Using TcpMonitor</h5>

<p>
To trace SOAP messages on the wire you can use TcpMon from Apache Axis. After setting the environment using <code>$GLOBUS_LOCATION/etc/globus-dev-env.[sh|csh|bat]</code> run: 
</p>
<pre>java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]</pre>

<p>If no arguments are used, you have to fill out these values in the GUI. Make
  sure to also start the standalone container with the <a href="../Java_WS_Core_Public_Interfaces.html#SUPPORTED_GLOBUS_OPTIONS">proxy
  server port</a> option set to the <code>listenPort</code> value.</p>

<h5><a name="usingmessagelogginghandler"></a>Using MessageLoggingHandler</h5>
<p>Another method for logging SOAP messages is to add the <code>org.globus.wsrf.handlers.MessageLoggingHandler</code> to the request or response chain in the <code>server-config.wsdd</code> or <code>client-config.wsdd</code> files. </p>
<p>For example: </p>
<pre>&lt;requestFlow&gt;<br>  ...<br>  &lt;handler type="java:org.globus.wsrf.handlers.MessageLoggingHandler"/&gt;<br>  ...<br>&lt;requestFlow&gt;</pre>
<p>Then you must enable logging for this handler class in the appropriate <code>log4j.properties</code> files and change the logging level to DEBUG: </p>
<pre>log4j.category.org.globus.wsrf.handlers.MessageLoggingHandler=DEBUG</pre>

<h5><a name="enablinglogging"></a>Enabling logging for Axis classes</h5>
<p>Another method for tracing SOAP messages is to enable logging for selected
Axis classes. Add the following lines to the appropriate <code>log4j.properties</code> files: </p>
<pre>
 log4j.category.org.apache.client.Call=DEBUG
 log4j.category.org.apache.axis.transport.http.HTTPSender=DEBUG
 # enable the following logger for HTTPS/HTTPG transport handlers
 log4j.category.org.globus.axis.axis.transport=DEBUG
</pre>
<p>
This will log Axis client side calls and Axis HTTP messages.
</p>

<h4><a name="debugginglog4j"></a>Debugging Log4j</h4>

<p>If you are having problems with configuring Log4j, you can enable internal
  Log4j debugging by adding <code>-Dlog4j.debug=true</code> option on the <code>java</code> command
  line or passing it via the <code><a href="../Java_WS_Core_Public_Interfaces.html#GLOBUS_OPTIONS">GLOBUS_OPTIONS</a></code> environment
  property.</p>

<h3><a name="testing">Writting and Running Tests</a></h3>
<p>Tests in the Java WS Core are based on the <a href="http://www.junit.org/">JUnit</a> API. JUnit must first be installed with Ant. To install JUnit with Ant copy the <code>junit.jar</code> found in JUnit distribution to the <code>$ANT_HOME/lib</code> directory.
</p>

<h4><a name="writingtests">Writing Tests</a></h4>
<p>
Always make sure to group your tests under <code>PackageTests.java</code> and/or <code>SecurityTests.java</code> test
suites. Put all tests that require any type of credentials in the <code>SecurityTests.java</code> test
suite. 
</p>

<p>
If you are writing  basic unit tests that do not require a container to run,
just use the regular JUnit classes to write such tests. </p>
<p>If you are writing
    tests that require a container to execute, use the <code>org.globus.wsrf.test.GridTestCase</code> class
    instead of <code>junit.framework.TestCase</code> as your base class for your
    tests. Also ensure your <code>PackageTests.java</code> or <code>SecurityTests.java</code> extends
    the <code>org.globus.wsrf.test.GridTestSuite</code> instead of <code>junit.framework.TestSuite</code>. </p>
The <code>org.globus.wsrf.test.GridTestSuite</code> and <code>org.globus.wsrf.test.GridTestCase</code> <strong>must</strong> be
used together. The <code>org.globus.wsrf.test.GridTestCase</code> class exposes
a <code>TEST_CONTAINER</code> variable that can be used to obtain the URL of
the container (<code>TEST_CONTAINER.getBaseURL()</code>). By default an embedded
container will be started for all tests in the test suite. To specify an external
container, pass <code>-Dweb.server.url=&lt;base.url&gt;</code> system property
on the <code>java</code> command line.

<h4><a name="runningtests">Running Tests</a></h4>
<p>
To execute the tests on the Java WS Core install, run the following (assuming
  the tests have been deployed into that install):

<pre>
cd $GLOBUS_LOCATION
ant -f share/globus_wsrf_test/runtests.xml runServer -Dtests.jar=&lt;test.jar&gt;
</pre>

<p>Where <code>&lt;test.jar&gt;</code> is an <b>absolute</b> path to the jar file that contains the tests. </p>
<p>By default, the tests that use a container will try to access a container
running at <code>http://localhost:8080/wsrf/services/</code>. </p>
<p>To specify a
    different container, use the <code>-Dtest.server.url=&lt;url&gt;</code> property.
</p>
<p>To execute PackageTests only, specify <code>-DbasicTestsOnly=true</code>.
</p>
<p>To execute SecurityTests only, specify <code>-DsecurityTestsOnly=true</code>. </p>
<p>  The test reports will be put in <code>$GLOBUS_LOCATION/share/globus_wsrf_test/test-reports</code> directory
            by default. The different test reports directory can be specified
    by passing <code>-Djunit.reports.dir=&lt;directory&gt;</code>.
</p>
            

</p>
<h3><a name="gardetails">GAR</a></h3>
<p>
The GAR (Grid Archive) file is a single file which contains all the files and information that the container needs to deploy a service. The GAR files are deployed using <a href="../Java_WS_Core_Public_Interfaces.html#deploygar">deployGar</a> and undeployed using <a href="../Java_WS_Core_Public_Interfaces.html#duneploygar">undeployGar</a> Ant tasks.

<h4>GAR file structure</h4>
<dl>
  <dt><code>docs/</code></dt>
  <dd>This directory contains service documentation files. </dd>
  <dt><code>share/</code></dt>
  <dd>This directory contains files that can be accessed or used by all services. </dd>
  <dt><code>schema/</code></dt>
  <dd>This directory contains service WSDL and schema files. </dd>
  <dt><code>etc/</code></dt>
  <dd>This directory contains service configuration files and a <code>post-deploy.xml</code> Ant script. </dd>
  <dt><code>bin/</code></dt>
  <dd>This directory contains service executables such as command line tools, GUI, etc. </dd>
  <dt><code>lib/</code></dt>
  <dd>This directory contains service and third party library files and any LICENSE files. </dd>
  <dt><code>server-deploy.wsdd</code></dt>
  <dd>This file is the server side deployment descriptor. </dd>
  <dt><code>client-deploy.wsdd</code></dt>
  <dd>This file is the client side deployment descriptor. </dd>
  <dt><code>jndi-config-deploy.xml</code></dt>
  <dd>This file is the JNDI configuration file. </dd>
</dl>
<h4>Creating a gar file through Ant</h4>

<p>
[FILL ME IN]
</p>

<h4><a name="gardeploy">GAR file deployment</a></h4>

<p>The contents of the GAR file are processed in the following way (all steps
  are performed only if necessary):</p>
<ul>
 <li>
  Any files in the <code>docs/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/docs/&lt;gar.id&gt;/</code> directory.
 </li>
 <li>
  Any files in the <code>share/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/share/&lt;gar.id&gt;/</code> directory.
 </li>
 <li>
  Any files in the <code>schema/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/share/schema/</code> directory.
 </li>
 <li>
  Any files in the <code>etc/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/</code> directory.
 </li>
 <li>
  Any files in the <code>bin/</code> directory in the GAR are copied into <code>$GLOBUS_LOCATION/bin/</code> directory.
 </li>
 <li>
  Any <code>.jar</code> files in the <code>lib/</code> directory of the GAR are
  copied into <code>$GLOBUS_LOCATION/lib/</code> directory.
 </li>
 <li>
  Any file that contains the word "LICENSE" in the name in the <code>lib/</code> directory
  of the GAR is copied into <code>$GLOBUS_LOCATION/share/licenses/</code> directory.
 </li>
 <li>
  The <code>server-deploy.wsdd</code> in the GAR is copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/server-config.wsdd</code>.
  If a profile name was specified during deployment, the <code>server-deploy.wsdd</code> will
  be copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-server-config.wsdd</code>.
  The <code>server-config.wsdd</code> file will be set with user-only access
  permissions.
 </li>
 <li>
  The <code>jndi-config-deploy.xml</code> in the GAR is copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/jndi-config.xml</code>.
  If a profile name was specified during deployment the <code>jndi-config-deploy.xml</code> will
  be copied to <code>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-jndi-config.xml</code>.
  The <code>jndi-config.xml</code> file will be set with user only-access permissions.
 </li>
 <li>
  The <code>client-deploy.wsdd</code> in the GAR is merged into a common <code>$GLOBUS_LOCATION/client-config.wsdd</code> file.
 </li>
 <li>
  An undeploy script (<code>$GLOBUS_LOCATION/etc/globus_packages/&lt;gar.id&gt;/undeploy.xml</code>) is created.
 </li>
 <li>
  A <code>etc/post-deploy.xml</code> Ant script is called if the GAR contains
  one. The <i>setup</i> target is called automatically.
 </li>

</ul>

<p>Notes:</p>
<ul>
  <li>If <code>post-deploy.xml</code> script creates some files, they will <strong>not</strong> be removed by
    <code>undeploy</code>. </li>
  <li>During deployment, filtering is done for contents of <code>server-deploy.wsdd</code> and <code>jndi-config-deploy.xml</code> files
      to replace the <code>@config.dir@</code> token
      with the "<code>etc/&lt;gar.id&gt;</code>" value, and the <code>@gar.id@</code> token
    with the "<code>&lt;gar.id&gt;</code>" value. </li>
</ul>
</p>


<h3><a name="CreatingLaunchers">Generating Launcher Scripts</a></h3>
<p>
Bourne Shell and Windows batch scripts can be automatically generated to hide the details of launching a Java program from the command line. 
<br>
To generate such a command line script write a Ant task that calls <code>generateLauncher</code> target in <code>$GLOBUS_LOCATION/share/globus_wsrf_common/build-launcher.xml</code>. The following properties/parameters must be specified:
</p>
<ul>
  <li><b><code>${launcher-name}</code></b> - the base name of script to generate</li>
  <li><b><code>${class.name}</code></b> - the name of Java class the script must call.</li>
</ul>
<p>
For example:
</p>
<pre>   ...
   &lt;property name="env.GLOBUS_LOCATION" value="."/&gt;
   &lt;property name="deploy.dir" location="${env.GLOBUS_LOCATION}"/&gt;
   &lt;property name="abs.deploy.dir" location="${deploy.dir}"/&gt;
   &lt;property name="build.launcher"
        location="${abs.deploy.dir}/share/globus_wsrf_common/build-launcher.xml"&gt;
   ...
   &lt;ant antfile="${build.launcher}" target="generateLauncher"&gt;
        &lt;property name="launcher-name" value="myClient"/&gt;
        &lt;property name="class.name" value="org.mypackage.MyClient"/&gt;
   &lt;/ant&gt;
</pre>
<p>
It is also possible to specify defaults JVM options and command-line
via the <code>default.jvm.options</code> and <code>default.cmd.line</code> parameters.<br>
In general the generation of the command line scripts is done in <code>post-deploy.xml</code> script during <a href="#gardeploy">GAR deployment</a>.
</p>


<?php include("/mcs/www-unix.globus.org/include/globus_footer.inc"); ?>
