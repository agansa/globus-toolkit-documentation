Index: src/org/apache/axis/MessageContext.java
===================================================================
RCS file: /home/cvs/ws-axis/java/src/org/apache/axis/MessageContext.java,v
retrieving revision 1.144
diff -w -u -r1.144 MessageContext.java
--- src/org/apache/axis/MessageContext.java	11 Jun 2004 19:09:07 -0000	1.144
+++ src/org/apache/axis/MessageContext.java	16 Jun 2005 19:25:30 -0000
@@ -379,9 +379,11 @@
      * during finalization, the dispose() method is called.
      * @see #dispose()
      */
+    /*
     protected void finalize() {
         dispose();
     }
+    */
 
     /**
      * Mappings of QNames to serializers/deserializers (and therfore
Index: src/org/apache/axis/client/Call.java
===================================================================
RCS file: /home/cvs/ws-axis/java/src/org/apache/axis/client/Call.java,v
retrieving revision 1.235
diff -w -u -r1.235 Call.java
--- src/org/apache/axis/client/Call.java	30 Nov 2004 21:54:32 -0000	1.235
+++ src/org/apache/axis/client/Call.java	16 Jun 2005 19:25:40 -0000
@@ -91,6 +91,7 @@
 import java.util.Map;
 import java.util.StringTokenizer;
 import java.util.Vector;
+import java.util.LinkedList;
 import java.rmi.RemoteException;
 
 /**
@@ -2779,10 +2780,116 @@
                 msgContext.removeProperty(Call.ONE_WAY);
             }
         };
+
+        NotificationManager.fireNotification(runnable);
+    }
+
+    private static class NotificationManager {
+
+        private static final int DEFAULT_NOTIFICATION_EXPONENT = 2;
+
+        private static double notificationExponent = getNotificationExponent();
+        private static NotificationManager notificationManager = 
+            new NotificationManager(notificationExponent);
+
+        public static void fireNotification(Runnable runnable) {
+            if (notificationExponent <= 1) {
         //create a thread to run it
         Thread thread = new Thread(runnable);
         //run it
         thread.start();
+            } else {
+                notificationManager.enqueue(runnable);
+            }
+        }
+
+        public static double getNotificationExponent() {
+            String prop = 
+                System.getProperty("axis.notificationThreadExponent");
+            return (prop == null) ? 
+                DEFAULT_NOTIFICATION_EXPONENT : Double.parseDouble(prop);
+        }
+        
+        // end of static stuff
+
+        private Queue queue;
+        private ArrayList threads;
+        private double exponent;
+        private int computedSize;
+
+        private NotificationManager(double exponent) {
+            this.exponent = exponent;
+            this.queue = new Queue();
+            this.threads = new ArrayList();
+            this.computedSize = 0;
+        }
+        
+        public void enqueue(Runnable r) {
+            int size = this.queue.enqueue(r);
+            addThread(size);
+        }
+        
+        private synchronized void computeSize() {
+            this.computedSize = 
+                (int)Math.pow(this.threads.size(), this.exponent);
+        }
+
+        private synchronized void addThread(int size) {
+            if (size > this.computedSize) {
+                NotificationThread thread = new NotificationThread();
+                thread.setDaemon(true);
+                this.threads.add(thread);
+                thread.start();
+                computeSize();
+            }
+        }
+
+        private synchronized void removeThread(Thread thread) {
+            this.threads.remove(thread);
+            computeSize();
+        }
+        
+        private class NotificationThread extends Thread {
+
+            public void run() {
+                Runnable r = null;
+                while(true) {
+                    try {
+                        r = (Runnable)queue.dequeue();
+                    } catch (InterruptedException e) {
+                        break;
+                    }
+                    if (r == null) {
+                        break;
+                    }
+                    try {
+                        r.run();
+                    } catch (Throwable e) {
+                        log.debug(Messages.getMessage("exceptionPrinting"), e);
+                    }
+                }
+                removeThread(this);
+            }
+        }
+    }
+    
+    private static class Queue {
+
+        private LinkedList queue = new LinkedList();
+        
+        public synchronized int enqueue(Runnable r) {
+            queue.add(r);
+            notify();
+            return queue.size();
+        }
+        
+        public synchronized Object dequeue() throws InterruptedException {
+            if (queue.isEmpty()) {
+                wait(1000 * 60 * 2);
+            }
+            return (queue.isEmpty()) ? null : queue.removeFirst();
+        }
+        
     }
 
     /**
Index: src/org/apache/axis/encoding/ser/BeanSerializer.java
===================================================================
RCS file: /home/cvs/ws-axis/java/src/org/apache/axis/encoding/ser/BeanSerializer.java,v
retrieving revision 1.80
diff -w -u -r1.80 BeanSerializer.java
--- src/org/apache/axis/encoding/ser/BeanSerializer.java	11 Jan 2005 23:35:48 -0000	1.80
+++ src/org/apache/axis/encoding/ser/BeanSerializer.java	16 Jun 2005 19:26:05 -0000
@@ -175,9 +175,11 @@
                         if (propValue == null) {
                             // an element cannot be null if nillable property is set to 
                             // "false" and the element cannot be omitted
+                            /*
                             if (!isNillable && !isOmittable) {
                                 throw new IOException(Messages.getMessage("nullNonNillableElement", propName));
                             }
+                            */
                             
                             // if meta data says minOccurs=0, then we can skip
                             // it if its value is null and we aren't doing SOAP
