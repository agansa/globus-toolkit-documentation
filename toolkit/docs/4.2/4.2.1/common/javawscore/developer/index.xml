<title> GT 4.0 Java WS Core : Developer's Guide</title>
<titleabbrev>Developer's Guide</titleabbrev>

<section id="s-javawscore-developer-introduction"><title>Introduction</title>
<para>This guide contains information of interest to developers working with Java
  WS Core. It provides reference information for application developers, including
  APIs, architecture, procedures for using the APIs and code samples.
</para>
</section>

<section id="s-javawscore-developer-archdes"><title>Architecture and design overview</title>

<itemizedlist>
  <listitem><simpara>Java WS Core Design Document [<ulink url="JavaWSCoreDesign.doc">doc</ulink> | <ulink url="JavaWSCoreDesign.pdf">pdf</ulink>]</simpara></listitem>
  <listitem><simpara>Java WS Core UML [<ulink url="JavaWSCoreUML.vsd">vsd</ulink> | <ulink url="Resource.gif">Resource (gif)</ulink>, <ulink url="ResourceProperty.gif">Resource Property (gif)</ulink>,  <ulink url="Notification.gif">Notification (gif)</ulink>]</simpara></listitem>
  <listitem><simpara>Java WS Core Notification UML Sequence Diagrams [<ulink url="NotificationSequences.vsd">vsd</ulink> | <ulink url="NotificationSequence1.jpg">Subscription (jpg)</ulink>, <ulink url="NotificationSequence2.jpg">Notification (jpg)</ulink>]</simpara></listitem>
</itemizedlist>
</section>

<section id="s-javawscore-developer-pubinterfaces"><title>Public interface</title>
<para>The semantics and syntax of the APIs and WSDL for the component, along with
  descriptions of domain-specific structured interface data, can be found in
  the <xref linkend="c-javawscore-Public_Interfaces"/>.</para>

</section>

<section id="s-javawscore-developer-scenarios"><title>Usage scenarios</title>

<section id="s-javawscore-developer-ApacheAddressing"><title>Using Apache Addressing API</title>
<para>
The WS-RF and WS-N specifications distributed with Java WS Core use <emphasis>WS-Addressing</emphasis> (the
March 2004 version of the specification) for addressing services and resources.
Java WS Core uses the <ulink url="http://ws.apache.org/ws-fx/addressing/">Apache
Addressing</ulink> library for WS-Addressing support. The API are pretty straightforward
and easy to use. Most of the work is done in <computeroutput>AddressingHandler</computeroutput> deployed
in the client and server configuration files. See <ulink url="http://ws.apache.org/ws-fx/addressing/">Apache
Addressing documentation</ulink> for details.
</para>
</section>

<section id="s-javawscore-developer-call"><title>Call object</title>

<para>If you are using the <computeroutput>javax.xml.rpc.Call</computeroutput> object directly, you can pass the addressing information by setting a <computeroutput>Constants.ENV_ADDRESSING_REQUEST_HEADERS</computeroutput> property on the call object. </para>
<para>For example:
<screen>
 Service service = new Service();
 Call call = (Call) service.createCall();

 String url = "http://localhost:8080/axis/services/Version";

 AddressingHeaders headers = new AddressingHeaders();
 headers.setTo(new To(url));

 // pass the addressing info to the addressing handler
 call.setProperty(Constants.ENV_ADDRESSING_REQUEST_HEADERS, headers);

 call.setTargetEndpointAddress(new URL(url));
 call.setOperationName(new QName(url, "getVersion")); // url here is just a namespace

 String ret = (String) call.invoke(new Object[]);
</screen>
</para>
</section>
<section id="s-javawscore-developer-addressinglocator"><title>AddressingLocator class</title>

<para>The Apache Addressing library also contains a version of Axis' WSDL2Java tool.
  It extends the Axis' WSDL2Java tool functionality by generating, in addition
  to all the regular classes, the <computeroutput>&lt;service&gt;Addressing</computeroutput> interface
and <computeroutput>&lt;service&gt;AddressingLocator</computeroutput> class. </para>
<para>The <computeroutput>AddressingLocator</computeroutput>  class can be used to get a stub for a service by passing Apache Addressing <computeroutput>EndpointReferenceType</computeroutput> parameter. </para>
<para>For example: 
<screen>
 String url = "http://localhost:8080/axis/services/Version";

 EndpointReferenceType epr = new EndpointReferenceType();
 epr.setAddress(new Address(url));

 VersionServiceAddressingLocator locator =
      new VersionServiceAddressingLocator();

 VerionServicePortType port = locator.getVersionPort(epr);

 port.getVersion();
</screen>
</para>
</section>
<section id="s-javawscore-developer-referenceproperties"><title>ReferenceProperties</title>

<para>In the WS-RF, WS-N specifications, the WS-Addressing <computeroutput>ReferenceProperties</computeroutput> are used to carry resource identity information. The resource identity can be anything as long as it serializes as a XML element. The <computeroutput>ReferenceProperties</computeroutput> are serialized as separate SOAP headers in the SOAP envelope.
</para>
<para> Apache Addressing library only allows a DOM <computeroutput>Element</computeroutput> or a <computeroutput>SOAPElement</computeroutput> to
  be a reference property. </para>
<para>For example, create <computeroutput>ReferencePropertiesType</computeroutput> and fill it with resource key info: 
<screen>
 // create a reference property
 QName keyName = new QName("http://axis.org", "VersionKey");
 String keyValue = "123";
 
 SimpleResourceKey key = new SimpleResourceKey(keyName, keyValue);

 ReferencePropertiesType props = new ReferencePropertiesType();

 // convert to SOAPElement and add to the list
 props.add(key.toSOAPElement()); 
 ...
</screen>

Then pass it to <computeroutput>AddressingHeaders</computeroutput>:

<screen>
 ...
 Service service = new Service();
 Call call = (Call) service.createCall();

 String url = "http://localhost:8080/axis/services/Version";

 AddressingHeaders headers = new AddressingHeaders();
 headers.setTo(new To(url));
 <emphasis>headers.setReferenceProperties(props);</emphasis>

 // pass the addressing info to the addressing handler
 call.setProperty(Constants.ENV_ADDRESSING_REQUEST_HEADERS, headers);

 call.setTargetEndpointAddress(new URL(url));
 call.setOperationName(new QName(url, "getVersion")); // url here is just a namespace

 String ret = (String) call.invoke(new Object[]);
</screen>

Or set it on <computeroutput>EndpointReferenceType</computeroutput>:

<screen>
 ...
 String url = "http://localhost:8080/axis/services/Version";

 EndpointReferenceType epr = new EndpointReferenceType();
 epr.setAddress(new Address(url));
 <emphasis>epr.setProperties(props);</emphasis>

 VersionServiceAddressingLocator locator =
     new VersionServiceAddressingLocator();

 VerionServicePortType port = locator.getVersionPort(epr);

 port.getVersion();
</screen>
</para>
</section>

<section id="s-javawscore-developer-NotificationConsumer"><title>Setting up and receiving notifications (Notification
    Consumer)</title>
<para>
There are a few steps involved in setting up and receiving notifications:</para>

<section id="s-javawscore-developer-callback"><title>Step 1: Implement the callback </title>
<para>
The notification consumer application must provide an implementation of the <computeroutput>org.globus.wsrf.NotifyCallback</computeroutput> interface. The <computeroutput>deliver</computeroutput> function of the interface will be invoked whenever a notification for that consumer arrives. The <computeroutput>message</computeroutput> parameter will either be of <computeroutput>org.w3c.dom.Element</computeroutput> type if the message type was unknown or some object mapped to the type of the message. </para>
<para><emphasis>Note:</emphasis> The <computeroutput>deliver</computeroutput> function should be thread-safe
    as multiple notifications might come at once. Notifications might also come
    unordered and some might even be lost (due to network failures). </para>
</section>
<section id="s-javawscore-developer-notificationconsumermgr"><title>Step 2: Start NotificationConsumerManager</title>
<para>
In order to facilitate the receipt of notifications, start a <computeroutput>NotificationConsumerManager</computeroutput> by
doing the following: 
<screen>
 import org.globus.wsrf.NotificationConsumerManager; 
 ...

 NotificationConsumerManager consumer = null;
 try {
    consumer = NotificationConsumerManager.getInstance();
    consumer.startListening();
    ...
</screen>

The <computeroutput>NotificationConsumerManager</computeroutput> starts an embedded container
through which the notifications are handled. </para>
</section>
<section id="s-javawscore-developer-registrationcallback"><title>Step 3: Register the callback</title>
<para>
Register the callback implementation with the <computeroutput>NotificationConsumerManager</computeroutput> (once
it is started) using the <computeroutput>createNotificationConsumer</computeroutput> function. </para>
<para>The <computeroutput>createNotificationConsumer</computeroutput> function
  returns an endpoint for this notification consumer. </para>
<para>Example:
<screen>
 import org.globus.wsrf.NotifyCallback;
 import org.apache.axis.message.addressing.EndpointReferenceType;
 ...

    MyCallback callback = new MyCallback();
    EndpointReferenceType consumerEPR =
        consumer.createNotificationConsumer(callback);
    ...

 class MyCallback implements NotifyCallback {
   ....
 }
</screen>
</para>
</section>
<section id="subscription"><title>Step 4: Subscribe to the callback</title>
<para>
Pass the endpoint returned by the <computeroutput>createNotificationConsumer</computeroutput> function
to the subscribe call. </para>
<para>Example: 
<screen>
 import org.oasis.wsn.TopicExpressionType;
 import org.oasis.wsn.Subscribe;
 import org.oasis.wsn.SubscribeResponse;
 import org.globus.wsrf.WSNConstants;
 import org.globus.wsrf.WSRFConstants;
 ...

    TopicExpressionType topicExpression = new TopicExpressionType();
    topicExpression.setDialect(WSNConstants.SIMPLE_TOPIC_DIALECT);
    topicExpression.setValue(WSRFConstants.TERMINATION_TIME);

    Subscribe request = new Subscribe();
    request.setUseNotify(Boolean.TRUE);
    request.setConsumerReference(consumerEPR);
    request.setTopicExpression(topicExpression);

    SubscribeResponse subResponse = port.subscribe(request);
    ...
</screen>
</para>
</section>
<section id="s-javawscore-developer-cleanup"><title>Step 5: Clean up</title>
<para>
Once done with the notifications, do the following clean up tasks.</para>

<formalpara><title>Step 5a: Destroy subscriptions resource</title>
<para>Make sure to
    explicitly destroy the subscription resource or set its termination time.Example: 
<screen>
 import org.globus.wsrf.core.notification.SubscriptionManager;
 import org.globus.wsrf.core.notification.service.SubscriptionManagerServiceAddressingLocator;
 import org.oasis.wsrf.lifetime.Destroy;
 ...

    SubscriptionManagerServiceAddressingLocator sLocator =
        new SubscriptionManagerServiceAddressingLocator();
    SubscriptionManager manager = sLocator.getSubscriptionManagerPort(
                        subResponse.getSubscriptionReference());
    manager.destroy(new Destroy());
    ...
</screen>
</para>
</formalpara>
<formalpara><title>Step 5b: Un-register the callback 
</title>
<para>
Make sure to  call (especially in error cases) the <emphasis><computeroutput>NotificationConsumerManager.removeNotificationConsumer()</computeroutput></emphasis> function
  to unregister the callback from the <computeroutput>NotificationConsumerManager</computeroutput>.
</para>
</formalpara>
<formalpara><title>Step 5c: Release resources </title>
<para>In addition, make sure to always call the <emphasis><computeroutput>NotificationConsumerManager.stopListening()</computeroutput></emphasis> function
  when finished using the <computeroutput>NotificationConsumerManager</computeroutput>. Otherwise,
  some resources might not be released. 
Example: 
<screen>
    ...
 } catch(Exception e) {
    ...
 } finally {
    if (consumer != null) {
       try { consumer.stopListening(); } catch (Exception ee) {}
    }
 }
</screen>
</para>
</formalpara>
</section>
</section>


<section id="s-javawscore-developer-EndpointInfo"><title>Obtaining container endpoint information</title>
<para>
In most cases, a service will need to return an endpoint information of the container to a client. Unfortunately, getting that information might not be easy. The only reliable way of getting the container endpoint information is to extract it from the <computeroutput>MessageContext.TRANS_URL</computeroutput> property of the <computeroutput>MessageContext/ResourceContext</computeroutput> associated with the current thread. We provide <computeroutput>ServiceHost</computeroutput> API to obtain that information easily, for example:

<screen>
 import org.globus.wsrf.container.ServiceHost;
 ...
 URL containerBaseUrl = ServiceHost.getBaseURL();
 ...
</screen>

The above will return the base container URL such as <computeroutput>http://localhost:8080/wsrf/services/</computeroutput>.
</para>
<para>We also provide convenient API for creating WS-Addressing endpoints, for example:

<screen>
 import org.apache.axis.message.addressing.EndpointReferenceType;
 import org.globus.wsrf.utils.AddressingUtils;
 ...
 EndpointReferenceType containerEndpoint = 
        AddressingUtils.createEndpointReference(null);
 ...
</screen>

The above will return the <computeroutput>EndpointReferenceType</computeroutput> object with the <computeroutput>Address</computeroutput> field set to the base container URL (as before) and empty reference properties.
</para>
<para>
<emphasis>Note:</emphasis> The <computeroutput>ServiceHost</computeroutput> API will return the correct information and <computeroutput>AddressingUtils</computeroutput> API will work correctly, only if called from the same thread as the service method was invoked from.
</para>

</section>

<section id="s-javawscore-developer-LocalInvocations"><title>Invoking services locally</title>

<para>
Services in the container can be invoked locally. Local invocations work just like remote invocations (all handlers are called, messages get serialized/deserialized) but messages do not travel over the network - everything happens in memory. 
</para>
<para>
Local invocations can only be made on the server side and only when a Axis MessageContext is associated with a current thread. URLs with "<emphasis>local</emphasis>" protocol name are used for local invocations. </para>
<para>To invoke a service locally, do the following: </para>
<table><title>TITLE</title>
<tgroup cols="2"><tbody>
<row>
<entry>1</entry>
<entry><para>Register "<emphasis>local</emphasis>" protocol handler:
<screen>
import org.globus.axis.transport.local.LocalTransportUtils;
...
<emphasis>LocalTransportUtils.init();</emphasis>
...
</screen></para></entry>
</row>
<row>
<entry>2</entry>
<entry><para>Create a service URL with "<emphasis>local</emphasis>" protocol:
<screen>
URL url = new URL(<emphasis>"local:///wsrf/services/MyService"</emphasis>);
</screen></para></entry>
</row>
<row>
<entry>3</entry>
<entry>><para>Configure the service stub for local invocation and make the call:
<screen>
MyServiceAddressingLocator locator = 
       new MyServiceAddressingLocator();
MyService port = locator.getMyServicePort(url);

<emphasis>LocalTransportUtils.enableLocalTransport((Stub)port);</emphasis>

port.hello();
</screen></para></entry>
</row>
</tbody></tgroup>
</table>

</section>

<section id="s-javawscore-developer-CustomExpressionEval"><title>Adding a new  query/topic expression
    evaluator</title>
<para>
Java WS Core allows for custom query/topic expression evaluators to be plugged in. The process of adding a new query/topic expression evaluator is composed of three steps:</para>

<section id="s-javawscore-developer-implementation"><title>Step 1: Implement the evaluator </title>
<table><title>TITLE</title>
<tgroup cols="2">
  <thead><row>
    <entry>If the evaluator is a... </entry>
    <entry>then it must implement: </entry>
  </row></thead>
<tbody>
  <row>
    <entry>query expression evaluator </entry>
    <entry><computeroutput>org.globus.wsrf.query.ExpressionEvaluator</computeroutput></entry>
  </row>
  <row>
    <entry>topic expression evaluator </entry>
    <entry><computeroutput>org.globus.wsrf.topicexpression.TopicExpressionEvaluator</computeroutput></entry>
  </row>
</tbody></tgroup>
</table>

</section>
<section id="s-javawscore-developer-registration"><title>Step 2: Register the evaluator </title>
<para>
The evaluators must be registered in order for Java WS Core to recognize them.
  The registration is done through the JNDI configuration file. The expression
  evaluators must be deployed as global resources under a specific subcontext. </para>

<section><title>Registering query expression evaluators </title>
<para>The query expression evaluators they must be deployed as global resources
  under the <emphasis><computeroutput>query/eval/</computeroutput></emphasis> subcontext in the JNDI configuration
  file. </para>
<para>
Example:

<screen>
 &lt;global&gt;
  &lt;resource name="query/eval/<emphasis>MyQueryExpressionEval</emphasis>"
            type="<emphasis>foo.bar.MyQueryExpressionEvaluator</emphasis>">
    &lt;resourceParams&gt;
     &lt;parameter&gt;
      &lt;name&gt;factory&lt;/name&gt;
      &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
     &lt;/parameter&gt;
    &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</screen>

where:

<table><title>TITLE</title>
<tgroup cols="2"><tbody>
  <row>
    <entry><computeroutput>name</computeroutput></entry>
    <entry> Specifies the name of the evaluator in JNDI space. The name can be arbitrary
      as long as it is unique and is in the right subcontext as explained above.</entry>
  </row>
  <row>
    <entry><computeroutput>type</computeroutput></entry>
    <entry>Specifies the class that implements the expression evaluator.</entry>
  </row>
</tbody></tgroup>
</table>
</para>
</section>

<section><title>Registering topic expression evaluators </title>
<para>The topic expression evaluators must be deployed as global resources under
  the <emphasis><computeroutput>topic/eval/</computeroutput></emphasis> subcontext in the JNDI configuration file. </para>
<para>Example:
<screen>
 &lt;global&gt;
  &lt;resource name="topic/eval/<emphasis>MyTopicExpressionEval</emphasis>"
            type="<emphasis>foo.bar.MyTopicExpressionEvaluator</emphasis>">
    &lt;resourceParams&gt;
     &lt;parameter&gt;
      &lt;name&gt;factory&lt;/name&gt;
      &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
     &lt;/parameter&gt;
    &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</screen>
where:</para>
<table><title>TITLE</title>
<tgroup cols="2"><tbody>
  <row>
    <entry><computeroutput>name</computeroutput></entry>
    <entry> Specifies the name of the evaluator in JNDI space. The name can be arbitrary
      as long as it is unique and is in the right subcontext as explained above.</entry>
  </row>
  <row>
    <entry><computeroutput>type</computeroutput></entry>
    <entry>Specifies the class that implements the expression evaluator.</entry>
  </row>
</tbody></tgroup>
</table>
</section>
</section>

<section id="s-javawscore-developer-registrationserializerdeserializer"><title>Step 3: Register
  the serializer/deserializer for the evaluator</title>
<para>
A serializer/deserializer must be registered for the dialect of the evaluator
  in order for the expression to be properly serialized and deserialized. The
  serializers/deserializers for the dialect are deployed as almost any other
  type mapping. In general, each type mapping specifies a type QName. For dialect
serializers/deserializers, that type QName takes a slightly different name.</para>

<section><title>Specifying the QName for query expression evaluators   </title>
<para>For query expression evaluators, that QName must have the local name part
    set to <emphasis><computeroutput>QueryExpressionDialect</computeroutput></emphasis> and
  namespace part set to the dialect of the query expression evaluator. </para>
<para>Example: </para>
<screen>
 &lt;typeMapping 
    encodingStyle="" 
    deserializer="org.apache.axis.encoding.ser.SimpleDeserializerFactory"
    serializer="org.apache.axis.encoding.ser.SimpleSerializerFactory"
    type="java:java.lang.String"
    qname="ns12:QueryExpressionDialect" 
    xmlns:ns12="http://foo.bar/MyQueryDialect"/&gt;
</screen>
<para>
  <emphasis>Note:</emphasis> that these type mappings must be deployed both on the
client and the server. </para>
</section>
<section><title>Specifying the QName for topic expression evaluators </title>
<para>For topic expression evaluators, that QName must have the local name part
  set to <emphasis><computeroutput>TopicExpressionDialect</computeroutput></emphasis> and
  namespace part set to the dialect of the topic expression evaluator. </para>
<para>Example:
<screen>
 &lt;typeMapping 
    encodingStyle="" 
    deserializer="org.apache.axis.encoding.ser.SimpleDeserializerFactory"
    serializer="org.apache.axis.encoding.ser.SimpleSerializerFactory"
    type="java:java.lang.String"
    qname="ns12:TopicExpressionDialect" 
    xmlns:ns12="http://foo.bar/MyTopicDialect"/&gt;
</screen>

<emphasis>Note:</emphasis> that these type mappings must be deployed both on the client and the server. 
</para>
</section>
</section>
</section>



<section id="s-javawscore-developer-GetCurrentMessageProvider"><title>Configuring a helper serializer for
    GetCurrentMessageProvider</title>
<para>
The standard <computeroutput>GetCurrentMessageProvider</computeroutput> might not know how to properly
serialize the notification message currently associated with the specified topic.
The <computeroutput>GetCurrentMessageProvider</computeroutput> can be configured to use a helper
serializer for a given notification message type. </para>
<para>To configure such a helper serializer,
  define the following global resource in your <computeroutput>deploy-jndi.xml</computeroutput> configuration
  file:
<screen>
 &lt;global&gt;
   &lt;resource
    name="providers/GetCurrentMessageProvider/<emphasis>foo.bar.MyNotificationMessage</emphasis>"
    type="<emphasis>foo.bar.MyMessageSerializer</emphasis>"&gt;
      &lt;resourceParams&gt;
        &lt;parameter&gt;
          &lt;name&gt;factory&lt;/name&gt;
          &lt;value&gt;org.globus.wsrf.jndi.BeanFactory&lt;/value&gt;
        &lt;/parameter&gt;
      &lt;/resourceParams&gt;
   &lt;/resource&gt;
 &lt;/global&gt;
</screen>
where:</para>
<table><title>TITLE</title>
<tgroup cols="2"><tbody>
  <row>
    <entry><computeroutput>name</computeroutput></entry>
    <entry>Must start with <emphasis><computeroutput>providers/GetCurrentMessageProvider/</computeroutput></emphasis> and
      must end with the full class name of the notification message. </entry>
  </row>
  <row>
    <entry><computeroutput>type</computeroutput></entry>
    <entry>Specifies the class that implements the <computeroutput>org.globus.wsrf.encoding.ObjectConverter</computeroutput> interface
      and is responsible for serializing the notification message. The <computeroutput>GetCurrentMessageProvider</computeroutput> will
    use the type of the notification message to find the helper serializer. </entry>
  </row>
</tbody></tgroup>
</table>
</section>

</section>

<section id="s-javawscore-developer-tasks"><title>Major programming tasks</title>
<para>...</para>
</section>


<section id="s-javawscore-developer-tutorials"><title>Tutorials</title>
<para>
<itemizedlist>
  <listitem><simpara>
   <ulink url="http://gdp.globus.org/gt4-tutorial/">The Globus Toolkit 4 Programmer's Tutorial by Borja Sotomayor</ulink>
  </simpara></listitem>
</itemizedlist>
</para>
</section>

<section id="s-javawscore-developer-features"><title>Feature summary</title>
&Java_WS_Core_Feature_Summary_Frag;
</section>

<section id="s-javawscore-developer-platforms"><title>Tested platforms</title>
&Java_WS_Core_Platform_Summary_Frag;
</section>

<section id="s-javawscore-developer-compatibility"><title>Backward compatibility summary</title>
&Java_WS_Core_Compatibility_Summary_Frag;
</section>

<section id="s-javawscore-developer-dependencies"><title>Technology dependencies</title>
&Java_WS_Core_Dependencies_Summary_Frag;
</section>

<section id="s-javawscore-developer-security_considerations"><title>Security Considerations </title>
&Java_WS_Core_Security_Considerations_Frag;
</section>






<section id="s-javawscore-developer-debugging"><title>Debugging</title>

<para>Logging in the Java WS Core is based on the <ulink url="http://jakarta.apache.org/commons/logging/">Jakarta Commons Logging</ulink> API. Commons Logging provides a consistent interface for instrumenting source code while at the same time allowing the user to plug-in a different logging implementation. Currently we use <ulink url="http://logging.apache.org/log4j/">Log4j</ulink> as a logging implementation. Log4j uses a separate configuration file to configure itself. Please see Log4j documentation for details on the <ulink url="http://logging.apache.org/log4j/docs/api/org/apache/log4j/PropertyConfigurator.html#doConfigure(java.lang.String, org.apache.log4j.spi.LoggerRepository)">configuration file format</ulink>.
</para>
<para>
Java WS Core is deployed with two Log4j configuration files:</para>
<itemizedlist>
 <listitem><simpara>
   <computeroutput>$GLOBUS_LOCATION/container-log4j.properties</computeroutput> (configures logging
   for the standalone container)</simpara></listitem>
 <listitem><simpara>
   <computeroutput>$GLOBUS_LOCATION/log4j.properties</computeroutput> (configures logging for everything
   else besides the standalone container)</simpara></listitem>
</itemizedlist>


<section id="s-javawscore-developer-tracingsoapmessages"><title>Tracing SOAP messages</title>

<section id="s-javawscore-developer-usingtcpmon"><title>Using TcpMonitor</title>

<para>
To trace SOAP messages on the wire you can use TcpMon from Apache Axis. After setting the environment using <computeroutput>$GLOBUS_LOCATION/etc/globus-dev-env.[sh|csh|bat]</computeroutput> run: 

<screen> $ java org.apache.axis.utils.tcpmon [listenPort targetHost targetPort]</screen>

If no arguments are used, you have to fill out these values in the GUI. Make
  sure to also start the standalone container with the proxy
  server port option set to the <computeroutput>listenPort</computeroutput> value.</para>

</section>
<section id="s-javawscore-developer-usingmessagelogginghandler"><title>Using MessageLoggingHandler</title>
<para>Another method for logging SOAP messages is to add the <computeroutput>org.globus.wsrf.handlers.MessageLoggingHandler</computeroutput> to the request or response chain in the <computeroutput>server-config.wsdd</computeroutput> or <computeroutput>client-config.wsdd</computeroutput> files. </para>
<para>For example:
<screen>&lt;requestFlow&gt;  ...  &lt;handler type="java:org.globus.wsrf.handlers.MessageLoggingHandler"/&gt;  ...&lt;requestFlow&gt;</screen>

Then you must enable logging for this handler class in the appropriate <computeroutput>log4j.properties</computeroutput> files and change the logging level to DEBUG: 
<screen>log4j.category.org.globus.wsrf.handlers.MessageLoggingHandler=DEBUG</screen>
</para>
</section>
<section id="s-javawscore-developer-enablinglogging"><title>Enabling logging for Axis classes</title>
<para>Another method for tracing SOAP messages is to enable logging for selected
Axis classes. Add the following lines to the appropriate <computeroutput>log4j.properties</computeroutput> files: 
<screen>
 log4j.category.org.apache.client.Call=DEBUG
 log4j.category.org.apache.axis.transport.http.HTTPSender=DEBUG
 # enable the following logger for HTTPS/HTTPG transport handlers
 log4j.category.org.globus.axis.axis.transport=DEBUG
</screen>

This will log Axis client side calls and Axis HTTP messages.
</para>
</section>
</section>

<section id="s-javawscore-developer-debugginglog4j"><title>Debugging Log4j</title>

<para>If you are having problems with configuring Log4j, you can enable internal
  Log4j debugging by adding <computeroutput>-Dlog4j.debug=true</computeroutput> option on the <computeroutput>java</computeroutput> command
  line or passing it via the <computeroutput>GLOBUS_OPTIONS</computeroutput> environment
  property.</para>

</section>
</section>








<section id="s-javawscore-developer-troubleshooting"><title>Troubleshooting</title>

<section id="s-javawscore-developer-nosocket"><title>No socket factory for 'https' protocol</title>
<para>
When a client fails with the following exception:
<screen>
 java.io.IOException: No socket factory for 'https' protocol
    at org.apache.axis.transport.http.HTTPSender.getSocket(HTTPSender.java:179)
    at org.apache.axis.transport.http.HTTPSender.writeToSocket(HTTPSender.java:397)
    at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:135)
</screen>
add the following to the client:
<screen>
 import org.globus.axis.util.Util;
 ...
 static {
     Util.registerTransport();
 }
 ...
</screen>
</para>
</section>
<section id="s-javawscore-developer-general"><title>General Troubleshooting Information</title>
&Java_WS_Core_Troubleshooting_Frag;
</section>

</section>




<section id="s-javawscore-developer-relateddocs"><title>Related Documentation</title>

<para>
Overview material about WSRF and WSN and more information on 
the implemented WSDL and schema can be found 
<ulink url="http://www.globus.org/wsrf/">here</ulink>.
</para>
<para>
Information about ongoing standards work can be found here: 
<itemizedlist>
  <listitem><simpara><ulink url="http://www.w3.org/2002/ws/addr/">WS-Addressing</ulink></simpara></listitem>
  <listitem><simpara><ulink url="http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wsrf">WS-ResourceFramework</ulink></simpara></listitem>
  <listitem><simpara><ulink url="http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=wsn">WS-Notification</ulink></simpara></listitem>
</itemizedlist>
</para>
</section>







<section id="s-javawscore-developer-miscellaneousinfo"><title>Appendices</title>


<section id="s-javawscore-developer-DocumentLiteral"><title>Document/literal rules </title>
<para>
The WS-RF and WS-N specifications schemas follow the <emphasis>document/literal</emphasis> mode as described in <ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html">WS-I Basic Profile</ulink>. The Basic Profile defines certain rules to follow for document/literal and
other modes to ensure interoperability. 
</para>
<para>
For example, for document/literal mode, at most one &lt;wsdl:part&gt; is allowed in the &lt;wsdl:message&gt; element and it has to define the 'element' attribute. Also, the wire signatures must be unique (cannot use the same 'element' attribute in &lt;wsdl:part&gt; in two different &lt;wsdl:message&gt; elements). 
</para>
<para>
Java WS Core relies on these restrictions so please keep them in mind when designing your own schema. 
</para>
<para>
<emphasis>Note:</emphasis> Axis' WSDL2Java tool might sometimes incorrectly detect
that schema follows the wrapped/literal mode and generate wrong stub and type
classes. To ensure that document/literal mode is always used:
<itemizedlist>
  <listitem><simpara> use Java WS Core's <computeroutput>generateStub*</computeroutput> Ant tasks in <computeroutput>&lt;install&gt;/share/globus_wsrf_tools/build-stubs.xml</computeroutput> file</simpara></listitem>
  <listitem><simpara> if you are using Axis' WSDL2Java tool directly, you can alternatively specify the <computeroutput>-W</computeroutput> command line option.
  </simpara></listitem>
</itemizedlist>
</para>
<para>  
Also, with wrapped/literal mode, the element name had to match the operation
 name in wsdl. This is <emphasis>not</emphasis> necessary with document/literal mode.
</para>

</section>
<section id="s-javawscore-developer-OperationProvider"><title>Configuring operation providers</title>
<para>
GT3 introduced a concept of <emphasis>operation providers</emphasis> where a service could be composed
of different parts/classes. Java WS Core also supports this functionality. In
  GT3 operation providers had to implement a specific interface. In Java WS Core <emphasis>no</emphasis> such
  interface is required. In fact, an operation provider is not in
  any way different from a standard web service. That means that <emphasis>any</emphasis> web
service implementation can automatically be used as an operation provider (as
long as it uses common or standard interfaces to operate on resources.)
</para>

<para>To enable operation provider support for your service, make the following
  changes to the service deployment descriptor: </para>
<table><title>TITLE</title>
<tgroup cols="2"><tbody>
  <row>
    <entry>1</entry>
    <entry>Change the value of the <computeroutput>provider</computeroutput> attribute to <computeroutput>Handler</computeroutput>.</entry>
  </row>
  <row>
    <entry>2</entry>
    <entry>Add a <computeroutput>handleClass</computeroutput> parameter with a value of <computeroutput>org.globus.axis.providers.RPCProvider</computeroutput>.</entry>
  </row>
  <row>
    <entry>3</entry>
    <entry><para>Specify providers in the <computeroutput>providers</computeroutput> parameter. </para>
      <para>The value
        of the parameter is a space-separated list of either provider names or
        class names. If provider names are used, they must  first be defined
        as  parameters in the <computeroutput>&lt;globalConfiguration&gt;</computeroutput> element
    of the <emphasis>main</emphasis> deployment descriptor (<computeroutput>etc\globus_wsrf_core\server-config.wsdd</computeroutput>). </para>
    <para>For example: </para>      <screen>
  &lt;globalConfiguration&gt;
  ...
   &lt;parameter name="s-javawscore-developer-GetRPProvider" 
              value="org.globus.wsrf.impl.properties.GetResourcePropertyProvider"/&gt;
  ...
  &lt;/globalConfiguration&gt;
</screen></entry>
  </row>
  <row>
    <entry>4</entry>
    <entry>Add or change the value of the <computeroutput>scope</computeroutput> parameter
      to <computeroutput>Application</computeroutput> or <computeroutput>Request</computeroutput></entry>
  </row>
</tbody></tgroup>
</table>
<para>The following is an example of a modified service deployment descriptor:
  

<screen>
    &lt;service name="s-javawscore-developer-SubscriptionManagerService" <emphasis>provider="Handler"</emphasis>
        use="literal" style="document"&gt;
        &lt;parameter name="allowedMethods" value="*"/&gt;
        <emphasis>&lt;parameter name="scope" value="Application"/&gt;</emphasis>
        <emphasis>&lt;parameter 
            name="providers"
            value="GetRPProvider 
                   org.globus.wsrf.impl.lifetime.SetTerminationTimeProvider
                   PauseSubscriptionProvider"/&gt;</emphasis>
        <emphasis>&lt;parameter 
            name="handlerClass" 
            value="org.globus.axis.providers.RPCProvider"/&gt;</emphasis>
        &lt;parameter name="className" 
            value="org.globus.wsrf.impl.notification.ResumeSubscriptionProvider"/&gt;
        &lt;wsdlFile>share/schema/core/notification/subscription_manager_service.wsdl&lt;/wsdlFile&gt;
    &lt;/service&gt;
</screen>

<emphasis>Note:</emphasis> The operations defined in the <computeroutput>className</computeroutput> service always
overwrite the providers' operations. That is, if one provider defines the same
method as the service specified in the <computeroutput>className</computeroutput> parameter, the
operation will be invoked on the service. Also, if two providers define the same
method, the first one specified in the <computeroutput>providers</computeroutput> parameter will be invoked.

</para>
</section>
<section id="s-javawscore-developer-JNDIDetails"><title>JNDI configuration file (<computeroutput>jndi-config.xml</computeroutput>) </title>
<para>
Java WS Core provides <ulink url="http://jakarta.apache.org/tomcat/tomcat-5.0-doc/jndi-resources-howto.html">Tomcat's JNDI</ulink> implementation. The file format of Java WS Core's <computeroutput>jndi-config.xml</computeroutput> is slightly different from the Tomcat's <computeroutput>server.xml</computeroutput> file. One main difference is that the <computeroutput>&lt;resourceParams&gt;</computeroutput> are specified as children of <computeroutput>&lt;resource&gt;</computeroutput> objects. Also, Java WS Core's <computeroutput>jndi-config.xml</computeroutput> parser is case sensitive and all elements names are lowercase. 
</para>
<para>All elements defined in the <computeroutput>&lt;global&gt;</computeroutput> section of the JNDI configuration file are deployed into the <computeroutput>java:comp/env</computeroutput> context under the name specified in the 'name' attribute. All <computeroutput>&lt;service&gt;</computeroutput> elements are deployed into <computeroutput>java:comp/env/services/&lt;service name&gt;</computeroutput> context. New objects and contexts can be added or modified dynamically at runtime but they will not be persisted. The only way to always have some object around is to deploy it in the <computeroutput>jndi-config.xml</computeroutput> file. All services <b>share</b> the same <computeroutput>java:comp/env</computeroutput> context. This is different from EJBs where each EJB has a separate <computeroutput>java:comp/env</computeroutput> context. 
</para>
<para>  
When deploying <computeroutput>&lt;resource&gt;</computeroutput> in <computeroutput>jndi-config.xml</computeroutput>,
make sure to use the <computeroutput>org.globus.wsrf.tools.jndi.BeanFactory</computeroutput> as a
BeanFactory (value of a 'factory' parameter) instead of <computeroutput>org.apache.naming.factory.BeanFactory</computeroutput>.
Your bean must have a default constructor. If your bean implements the <computeroutput>org.globus.wsrf.jndi.Initializable</computeroutput> interface,
the <computeroutput>initialize()</computeroutput> function will be automatically called after all
parameters are set on the bean. 
</para>
<para> 
Please see <ulink url="http://java.sun.com/products/jndi/tutorial/">The JNDI Tutorial</ulink> for more information on JNDI programming. 
</para>

</section>
<section id="s-javawscore-developer-WritingClients"><title>Client notes</title>
<para>
Any program that is based on Java WS Core should contain as a first entry in its classpath the directory of the Java WS Core installation. This is to ensure that the right <computeroutput>client-config.wsdd</computeroutput> is used by the client. That configuration file contains important client-side information such as handlers, type mappings, etc.
</para>
<para>
Also, any program that is a notification consumer should be initialized with
  the appropriate <computeroutput>GLOBUS_LOCATION</computeroutput> system property (set to the installation
  directory of Java WS Core). If the system property is not set, the notification
  consumer might not initialize or work properly.
</para>

</section>
<section id="s-javawscore-developer-ContextProperties"><title>MessageContext properties</title>
<para>
The following properties can be obtained from the SOAPContext/MessageContext associated with the current thread:

<itemizedlist>
<listitem><simpara>
<emphasis><computeroutput>org.apache.axis.Constants.MC_HOME_DIR</computeroutput></emphasis> - the base directory from which the wsdl files are loaded from. 
</simpara></listitem>
<listitem><simpara>
<emphasis><computeroutput>org.apache.axis.Constants.MC_CONFIGPATH</computeroutput></emphasis> - the base directory from which different configuration files are loaded from. 
</simpara></listitem>
<listitem><simpara>
<emphasis><computeroutput>org.apache.axis.Constants.MC_REMOTE_ADDR</computeroutput></emphasis> - contains the IP address of the client
</simpara></listitem>
<listitem><simpara>
<emphasis><computeroutput>org.apache.axis.MessageContext.TRANS_URL</computeroutput></emphasis> - the URL of the request
</simpara></listitem>
</itemizedlist>
</para>
<para>
The <computeroutput>Constants.MC_CONFIGPATH</computeroutput> property should be used to load any type of configuration files. Only <computeroutput>Constants.MC_CONFIGPATH</computeroutput> and <computeroutput>Constants.MC_HOME_DIR</computeroutput> are associated with thread during activation.

In the standalone container the <computeroutput>Constants.MC_HOME_DIR</computeroutput> and <computeroutput>Constants.MC_CONFIGPATH</computeroutput> properties will usually point to the same directory. However, in Tomcat they will point to two different directories.
</para>

</section>
<section id="s-javawscore-developer-testing"><title>Writing and running tests</title>
<para>Tests in the Java WS Core are based on the <ulink url="http://www.junit.org/">JUnit</ulink> API. JUnit must first be installed with Ant. To install JUnit with Ant copy the <computeroutput>junit.jar</computeroutput> found in JUnit distribution to the <computeroutput>$ANT_HOME/lib</computeroutput> directory.
</para>

<section id="s-javawscore-developer-writingtests"><title>Writing Tests</title>
<para>
Always make sure to group your tests under <computeroutput>PackageTests.java</computeroutput> and/or <computeroutput>SecurityTests.java</computeroutput> test
suites. Put all tests that require any type of credentials in the <computeroutput>SecurityTests.java</computeroutput> test
suite. 
</para>

<para>
If you are writing  basic unit tests that do not require a container to run,
just use the regular JUnit classes to write such tests. </para>
<para>If you are writing
    tests that require a container to execute, use the <computeroutput>org.globus.wsrf.test.GridTestCase</computeroutput> class
    instead of <computeroutput>junit.framework.TestCase</computeroutput> as your base class for your
    tests. Also ensure your <computeroutput>PackageTests.java</computeroutput> or <computeroutput>SecurityTests.java</computeroutput> extends
    the <computeroutput>org.globus.wsrf.test.GridTestSuite</computeroutput> instead of <computeroutput>junit.framework.TestSuite</computeroutput>. </para>
<para>The <computeroutput>org.globus.wsrf.test.GridTestSuite</computeroutput> and <computeroutput>org.globus.wsrf.test.GridTestCase</computeroutput> <emphasis>must</emphasis> be
used together. The <computeroutput>org.globus.wsrf.test.GridTestCase</computeroutput> class exposes
a <computeroutput>TEST_CONTAINER</computeroutput> variable that can be used to obtain the URL of
the container (<computeroutput>TEST_CONTAINER.getBaseURL()</computeroutput>). By default an embedded
container will be started for all tests in the test suite. To specify an external
container, pass <computeroutput>-Dweb.server.url=&lt;base.url&gt;</computeroutput> system property
on the <computeroutput>java</computeroutput> command line.
</para>
</section>
<section id="s-javawscore-developer-runningtests"><title>Running Tests</title>
<para>
To execute the tests on the Java WS Core install, run the following (assuming
  the tests have been deployed into that install):

<screen>
$ cd $GLOBUS_LOCATION
$ ant -f share/globus_wsrf_test/runtests.xml runServer -Dtests.jar=&lt;test.jar&gt;
</screen>
Where <computeroutput>&lt;test.jar&gt;</computeroutput> is an <emphasis>absolute</emphasis> path to the jar file that contains the tests. </para>
<para>By default, the tests that use a container will try to access a container
running at <computeroutput>http://localhost:8080/wsrf/services/</computeroutput>. </para>
<para>To specify a
    different container, use the <computeroutput>-Dtest.server.url=&lt;url&gt;</computeroutput> property.
</para>
<para>To execute PackageTests only, specify <computeroutput>-DbasicTestsOnly=true</computeroutput>.
</para>
<para>To execute SecurityTests only, specify <computeroutput>-DsecurityTestsOnly=true</computeroutput>. </para>
<para>  The test reports will be put in <computeroutput>$GLOBUS_LOCATION/share/globus_wsrf_test/test-reports</computeroutput> directory
            by default. The different test reports directory can be specified
    by passing <computeroutput>-Djunit.reports.dir=&lt;directory&gt;</computeroutput>.
</para>
</section>            
</section>

<section id="s-javawscore-developer-gardetails"><title>Building and deploying Grid services (GAR) </title>
<para>
The GAR (Grid Archive) file is a single file which contains all the files and information that the container needs to deploy a service. The GAR files are deployed using deployGar (xref linkend="s-javawscore-Public_Interfaces-deployGar"/>)and undeployed using undeployGar (<xref linkend="undeployGar"/> Ant tasks.
</para>

<section><title>GAR file structure</title>
<table><title>TITLE</title>
<tgroup cols="2"><tbody>
  <row><entry><computeroutput>docs/</computeroutput></entry>
  <entry>This directory contains service documentation files. </entry>
</row>
  <row><entry><computeroutput>share/</computeroutput></entry>
  <entry>This directory contains files that can be accessed or used by all services. </entry>
</row>
  <row><entry><computeroutput>schema/</computeroutput></entry>
  <entry>This directory contains service WSDL and schema files. </entry>
</row>
  <row><entry><computeroutput>etc/</computeroutput></entry>
  <entry>This directory contains service configuration files and a <computeroutput>post-deploy.xml</computeroutput> Ant script. </entry>
</row>
  <row><entry><computeroutput>bin/</computeroutput></entry>
  <entry>This directory contains service executables such as command line tools, GUI, etc. </entry>
</row>
  <row><entry><computeroutput>lib/</computeroutput></entry>
  <entry>This directory contains service and third party library files and any LICENSE files. </entry>
</row>
  <row><entry><computeroutput>server-deploy.wsdd</computeroutput></entry>
  <entry>This file is the server side deployment descriptor. </entry>
</row>
  <row><entry><computeroutput>client-deploy.wsdd</computeroutput></entry>
  <entry>This file is the client side deployment descriptor. </entry>
</row>
  <row><entry><computeroutput>jndi-config-deploy.xml</computeroutput></entry>
  <entry>This file is the JNDI configuration file. </entry>
</row>
</tbody></tgroup>
</table>
</section>
<section><title>Creating a GAR file through Ant</title>

<section><title>Creating GAR file</title>
<para>
To create a GAR file use the following (for example):
</para>
<screen>
 &lt;property name="build.packages" location=
      "${deploy.dir}/share/globus_wsrf_common/build-packages.xml"/&gt;
 ...
 &lt;property name="garjars.id" value="garjars"/&gt;
 &lt;fileset dir="lib" id="garjars"/&gt;

 &lt;property name="garetc.id" value="garetc"/&gt;
 &lt;fileset dir="etc" id="garetc"/&gt;
 ...
 &lt;target name="dist" depends="..."&gt;
   &lt;ant antfile="${build.packages}" target="makeGar"&gt;
     &lt;property name="gar.name" value="mygar.gar"/&gt;
     &lt;reference refid="${garjars.id}"/&gt;
     &lt;reference refid="${garetc.id}"/&gt;
   &lt;/ant>            
 &lt;/target>
</screen>
<para>
The <computeroutput>gar.name</computeroutput> property must be passed. That property specifies the gar file to create. The <computeroutput>makeGar</computeroutput> task will look for <computeroutput>deploy-client.wsdd</computeroutput>, <computeroutput>deploy-server.wsdd</computeroutput>, and <computeroutput>deploy-jndi-config.xml</computeroutput> files in the base directory of the calling Ant process. All of these files are optional and do not have exist. The list of files to be included in the GAR file is passed via Ant references. The <computeroutput>makeGar</computeroutput> accpets the following references: <computeroutput>garjars.id</computeroutput>, <computeroutput>garschema.id</computeroutput>, <computeroutput>garetc.id</computeroutput>, <computeroutput>garshare.id</computeroutput>, <computeroutput>gardocs.id</computeroutput>, and <computeroutput>garbin.id</computeroutput>. All of these references are optional and do not have to be defined.</para>
<para>
In the above example, all files in the <computeroutput>etc</computeroutput> and <computeroutput>lib</computeroutput> directories, and <computeroutput>deploy-client.wsdd</computeroutput>, <computeroutput>deploy-server.wsdd</computeroutput>, <computeroutput>deploy-jndi-config.xml</computeroutput> files (if they exist) will be included into the GAR file.
</para>

</section>
<section><title>Deploying GAR file</title>
<para>
To deploy a GAR file use the following (for example):
</para>
<screen>
 &lt;property name="build.packages" location=
      "${deploy.dir}/share/globus_wsrf_common/build-packages.xml"/&gt;
 ...
 &lt;target name="deploy" depends="..."&gt;
   &lt;ant antfile="${build.packages}" target="deployGar"&gt;
     &lt;property name="gar.name" value="mygar.gar"/&gt;
   &lt;/ant&gt;
 &lt;/target&gt;
</screen>
<para>
The <computeroutput>gar.name</computeroutput> property must be passed. That property specifies the gar file to deploy. Optionally, <computeroutput>profile</computeroutput> property can be passed to indicate which configuration profile the gar should be deployed under.
</para>

</section>
<section><title>Undeploying GAR file</title>
<para>
To undeploy a GAR file use the following (for example):
</para>
<screen>
 &lt;property name="build.packages" location=
      "${deploy.dir}/share/globus_wsrf_common/build-packages.xml"/&gt;
 ...
 &lt;target name="undeploy"&gt;
   &lt;ant antfile="${build.packages}" target="undeployGar"&gt;
     &lt;property name="gar.id" value="mygar"/&gt;
   &lt;/ant&gt;
 &lt;/target&gt;
</screen>
<para>
The <computeroutput>gar.id</computeroutput> property must be passed. That property specifies the base name of the gar to undeploy.
</para>
</section>
</section>
<section id="s-javawscore-developer-gardeploy"><title>GAR file deployment</title>

<para>The contents of the GAR file are processed in the following way (all steps
  are performed only if necessary):</para>
<itemizedlist>
 <listitem><simpara>
  Any files in the <computeroutput>docs/</computeroutput> directory in the GAR are copied into <computeroutput>$GLOBUS_LOCATION/docs/&lt;gar.id&gt;/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  Any files in the <computeroutput>share/</computeroutput> directory in the GAR are copied into <computeroutput>$GLOBUS_LOCATION/share/&lt;gar.id&gt;/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  Any files in the <computeroutput>schema/</computeroutput> directory in the GAR are copied into <computeroutput>$GLOBUS_LOCATION/share/schema/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  Any files in the <computeroutput>etc/</computeroutput> directory in the GAR are copied into <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  Any files in the <computeroutput>bin/</computeroutput> directory in the GAR are copied into <computeroutput>$GLOBUS_LOCATION/bin/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  Any <computeroutput>.jar</computeroutput> files in the <computeroutput>lib/</computeroutput> directory of the GAR are
  copied into <computeroutput>$GLOBUS_LOCATION/lib/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  Any file that contains the word "LICENSE" in the name in the <computeroutput>lib/</computeroutput> directory
  of the GAR is copied into <computeroutput>$GLOBUS_LOCATION/share/licenses/</computeroutput> directory.
 </simpara></listitem>
 <listitem><simpara>
  The <computeroutput>server-deploy.wsdd</computeroutput> in the GAR is copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/server-config.wsdd</computeroutput>.
  If a profile name was specified during deployment, the <computeroutput>server-deploy.wsdd</computeroutput> will
  be copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-server-config.wsdd</computeroutput>.
  The <computeroutput>server-config.wsdd</computeroutput> file will be set with user-only access
  permissions.
 </simpara></listitem>
 <listitem><simpara>
  The <computeroutput>jndi-config-deploy.xml</computeroutput> in the GAR is copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/jndi-config.xml</computeroutput>.
  If a profile name was specified during deployment the <computeroutput>jndi-config-deploy.xml</computeroutput> will
  be copied to <computeroutput>$GLOBUS_LOCATION/etc/&lt;gar.id&gt;/&lt;profile.name&gt;-jndi-config.xml</computeroutput>.
  The <computeroutput>jndi-config.xml</computeroutput> file will be set with user only-access permissions.
 </simpara></listitem>
 <listitem><simpara>
  The <computeroutput>client-deploy.wsdd</computeroutput> in the GAR is merged into a common <computeroutput>$GLOBUS_LOCATION/client-config.wsdd</computeroutput> file.
 </simpara></listitem>
 <listitem><simpara>
  An undeploy script (<computeroutput>$GLOBUS_LOCATION/etc/globus_packages/&lt;gar.id&gt;/undeploy.xml</computeroutput>) is created.
 </simpara></listitem>
 <listitem><simpara>
  A <computeroutput>etc/post-deploy.xml</computeroutput> Ant script is called if the GAR contains
  one. The <emphasis>setup</emphasis> target is called automatically.
 </simpara></listitem>

</itemizedlist>

<para>Notes:</para>
<itemizedlist>
  <listitem><simpara>If <computeroutput>post-deploy.xml</computeroutput> script creates some files, they will <emphasis>not</emphasis> be removed by
    <computeroutput>undeploy</computeroutput>. </simpara></listitem>
  <listitem><simpara>During deployment, filtering is done for contents of <computeroutput>server-deploy.wsdd</computeroutput> and <computeroutput>jndi-config-deploy.xml</computeroutput> files
      to replace the <computeroutput>@config.dir@</computeroutput> token
      with the "<computeroutput>etc/&lt;gar.id&gt;</computeroutput>" value, and the <computeroutput>@gar.id@</computeroutput> token
    with the "<computeroutput>&lt;gar.id&gt;</computeroutput>" value. </simpara></listitem>
</itemizedlist>
</section>
</section>

<section id="CreatingLaunchers"><title>Generating launcher scripts</title>
<para>
Bourne Shell and Windows batch scripts can be automatically generated to hide the details of launching a Java program from the command line. 
</para>
<para>  To generate such a command line script, write a Ant task that calls <computeroutput>generateLauncher</computeroutput> target
    in <computeroutput>$GLOBUS_LOCATION/share/globus_wsrf_common/build-launcher.xml</computeroutput>.
    The following properties/parameters must be specified: </para>
<itemizedlist>
  <listitem><simpara><emphasis><computeroutput>${launcher-name}</computeroutput></emphasis> - the base name of script to generate</simpara></listitem>
  <listitem><simpara><emphasis><computeroutput>${class.name}</computeroutput></emphasis> - the name of Java class the script must call.</simpara></listitem>
</itemizedlist>
<para>
For example:

<screen>   ...
   &lt;property name="env.GLOBUS_LOCATION" value="."/&gt;
   &lt;property name="deploy.dir" location="${env.GLOBUS_LOCATION}"/&gt;
   &lt;property name="abs.deploy.dir" location="${deploy.dir}"/&gt;
   &lt;property name="build.launcher"
        location="${abs.deploy.dir}/share/globus_wsrf_common/build-launcher.xml"&gt;
   ...
   &lt;ant antfile="${build.launcher}" target="generateLauncher"&gt;
        &lt;property name="launcher-name" value="myClient"/&gt;
        &lt;property name="class.name" value="org.mypackage.MyClient"/&gt;
   &lt;/ant&gt;
</screen>

It is also possible to specify defaults JVM options and command-line
via the <computeroutput>default.jvm.options</computeroutput> and <computeroutput>default.cmd.line</computeroutput> parameters.</para>
<para>  In general the generation of the command line scripts is done in <computeroutput>post-deploy.xml</computeroutput> script
    during GAR deployment (<xref linkend="deployGar"/>). </para>
</section>

<section id="s-javawscore-developer-ProxySupport"><title>Proxy support</title>
<para>
A basic proxy support is provided. A <emphasis><computeroutput>org.globus.wsrf.proxy.port</computeroutput></emphasis> system
property can be set to the port of the proxy server (the proxy server must run
on the same machine as the container). This will make any code that uses <computeroutput>ServiceHost</computeroutput> or <computeroutput>AddressingUtils</computeroutput> API
return the address of the proxy server instead of the container. This could be
useful, for example, for debugging purposes.
The <emphasis><computeroutput>org.globus.wsrf.proxy.port</computeroutput></emphasis> system property can be passed to <computeroutput>globus-start-container</computeroutput> script via <computeroutput>GLOBUS_OPTIONS</computeroutput> environment property. For example:

<screen>
 setenv GLOBUS_OPTIONS="-Dorg.globus.wsrf.proxy.port=5555"
 globus-start-container
</screen>
Please note that not all of the core code will obey the proxy port setting.
</para>

</section>

<section id="Activation"><title>Lifecycle and activation</title>

<section><title>Activating a service</title>
<para>To activate a service, an RPCProvider is available from both Axis and Globus. </para>
</section>

<section><title>Activating a service using the Axis RPCProvider</title>

<para>
The <computeroutput>scope</computeroutput> setting of the service dictates when and how service instances
are created:</para>
<table><title>TITLE</title>
<tgroup cols="2"><tbody>

  <row>
    <entry><emphasis>Application</emphasis></entry>
    <entry>One instance of the service is used for all invocations.</entry>
  </row>
  <row>
    <entry><emphasis>Request</emphasis></entry>
    <entry>One instance is created per invocation. This is the default (if scope
    parameter is not set in the deployment descriptor).</entry>
  </row>
  <row>
    <entry><emphasis>Session</emphasis></entry>
    <entry> One instance is created per session. </entry>
  </row>
</tbody></tgroup>
</table>
<para>If the service
        implements the <ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/rpc/server/ServiceLifecycle.html">javax.xml.rpc.server.ServiceLifecycle</ulink> interface,
        the lifecycle methods  will be called according to the <computeroutput>scope</computeroutput> setting
  as a service instance is created and destroyed. </para>
<para>For example, in <emphasis>Application</emphasis> scope, <emphasis>destroy()</emphasis> will
          be called on container shutdown, and in <emphasis>Request</emphasis> scope it will
be called after the service method is called. </para>
<para>  With Axis RPCProvider, JAAS credentials are never associated with the
invocation thread. </para>
</section>
<section><title>Activating a service using the Globus RPCProvider</title>

<para>
The <computeroutput>scope</computeroutput> setting of the service dictates when and how service instances
are created (only <emphasis>Application</emphasis> and <emphasis>Request</emphasis> scopes are supported
with Globus RPCProvider):</para>

<table><title>TITLE</title>
<tgroup cols="2"><tbody>
  <row>
    <entry><emphasis>Application</emphasis></entry>
    <entry><para>Service/provider instances are created either on first invocation
        or on container startup. The behavior is determined by the value 
        of the 
        "loadOnStartup" 
        parameter. This will work in the same way in both the stand-alone 
        container and in Tomcat. </para>
      <para>        If the service or the container is configured with a security
        descriptor, the appropriate credentials will be associated with the thread
        during activation (using JAAS). Also, during activation a basic Axis
        MessageContext will be associated with the thread with only <emphasis>Constants.MC_HOME_DIR</emphasis>, <emphasis>Constants.MC_CONFIGPATH</emphasis>,
    and the right target service properties set (see <xref linkend="s-javawscore-developer-ContextProperties"/> for details). If service or providers implement the <ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/rpc/server/ServiceLifecycle.html">javax.xml.rpc.server.ServiceLifecycle</ulink> interface,
    the lifecycle methods will be called accordingly. </para></entry>
  </row>
  <row>
    <entry><emphasis>Request</emphasis></entry>
    <entry><para>One instance is created per invocation. This is the default (if scope
      parameter is not set in the deployment descriptor).</para>
      <para>Behaves more or less just like the Axis RPCProvider (service/providers
        instances are created per invocation, ServiceLifecycle methods called
        right before and after service method invocation, no JAAS credentials
      during ServiceLifecycle methods). </para></entry>
  </row>
</tbody></tgroup>
</table>
</section>
<section><title>Activating a ResourceHome</title>

<para>
A ResourceHome will be activated either on the first service invocation or, 
if <emphasis>"loadOnStartup"</emphasis> parameter  is set to <emphasis>"true"</emphasis>, during container 
startup. Both mechanisms trigger actual activation by looking up the ResourceHome 
in the JNDI directory. This initial lookup causes a proper MessageContext 
and/or JAAS subject to be associated with the current thread, instantiation of 
the object implementing the ResourceHome and, if the ResourceHome implements the 
<emphasis>org.globus.wsrf.jndi.Initializable</emphasis> interface, the invocation of the 
<emphasis>initialize()</emphasis> function.
</para>
<para>
In fact, the same steps are performed upon initial lookup of any JNDI <emphasis>resource</emphasis> entry that 
uses the <emphasis>org.globus.wsrf.jndi.BeanFactory</emphasis> class for its factory and is defined directly 
under a <emphasis>service</emphasis> entry in a <emphasis>jndi-config.xml</emphasis> file.
</para>

</section>
<section><title>Activating ServiceResourceHome</title>

<para>
If you are using a ServiceResourceHome please make sure to deploy the service with the <emphasis>"loadOnStartup"</emphasis> option enabled and in <emphasis>Application</emphasis> scope. That will ensure that the ResourceHome is initialized with the right service/resource.
</para>
</section>
</section>
</section>




